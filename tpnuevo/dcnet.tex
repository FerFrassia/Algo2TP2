\section{DCNet}

\begin{Interfaz}
  
  %\textbf{parámetros formales}\hangindent=2\parindent\\
  %\parbox{1.7cm}{\textbf{géneros}} \\
  %\parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    %\InterfazFuncion{Verifica?}{\In{c}{conj(tag)}, \In{r}{rest}}{$\alpha$}
    %{$res \igobs a$}
    %[$\Theta(copy(a))$]
    %[función de copia de $\alpha$'s]
  %}

  \textbf{se explica con}: \tadNombre{DCNet, Iterador Unidireccional($\alpha$)}.

  \textbf{géneros}: \TipoVariable{dcnet}.

  \Titulo{Operaciones básicas de DCNet}
	

  \InterfazFuncion{Red}{\In {d}{dcnet}}{red}
  %[ACA VA EL PRE (SI LO HUBIERA)]
  {$res \igobs$ red($d$)}
  [\Complejidad{1}]
  [Devuelve la red del dcnet.]
  
  \InterfazFuncion{CaminoRecorrido}{\In {d}{dcnet}, \In{p}{paquete} }{secu(compu)}
  [$p$ $\in$ paqueteEnTransito?($d,p$)]
  {$res \igobs$ caminoRecorrido($d,p$))}
  [\Complejidad{n*log_2 (K)}]
  [Devuelve una secuencia con las computadoras por las que paso el paquete.]
  
  \InterfazFuncion{cantidadEnviados}{\In {d}{dcnet}, \In {c}{compu}}{nat}
  [$c$ $\in$ computadoras(red($d$))]
  {$res \igobs$ cantidadEnviados($d,c$)}
  [\Complejidad{1}]
  [Devuelve la cantidad de paquetes que fueron enviados desde la computadora.]
  
  \InterfazFuncion{enEspera}{\In {d}{dcnet}, \In {c}{compu}}{itPaquete}
  [$c$ $\in$ computadoras(red($d$))]
  {$res \igobs$ enEspera($d,c$)}
  [\Complejidad{1}]
  [Devuelve los paquetes que se encuentran en ese momento en la computadora.]
  
  \InterfazFuncion{IniciarDCNet}{\In {r}{red}}{dcnet}
  %[ACA VA EL PRE (SI LO HUBIERA)]
  {$res \igobs$ iniciarDCNet($r$)}
  [\Complejidad{1}]
  [Inicia un dcnet con la red y sin paquetes.]

  \InterfazFuncion{CrearPaquete}{\In {p}{paquete}, \Inout {d}{dcnet}}{}
  [$d_0 \equiv d$ $\wedge$ $\neg$ (($\exists$ $p_1$: paquete)(paqueteEnTransito($s,p_1$) $\wedge$ id($p_1$) $=$ id($p$)) $\wedge$ origen($p$) $\in$ computadoras(red($d$))$\yluego$ destino($p$) $\in$ computadoras(red($d$))$\yluego$ hayCamino?(red($d$,origen($p$),destino($p$))  ]
  {$res \igobs$ iniciarDCNet($r$)}
  [\Complejidad{}]
  [Agrega el paquete al dcnet.]
  
  \InterfazFuncion{AvanzarSegundo}{\Inout {d}{dcnet)}}{}
  [$d_0 \equiv d$ ]
  {$d$ $\igobs$ avanzarSegundo($c_0$)}
  [\Complejidad{}]
  [El paquete de mayor prioridad de cada computadora avanza a su proxima computadora siendo esta la del camino mas corto.]
	
	\Titulo{Operaciones del iterador}
  
  \InterfazFuncion{crearIt}{\In{c}{ciudad}}{itRURs}
  %[$c_0 \equiv c$ $\wedge$ $e$ $\in$ estaciones($c_0$)]
  {res $\igobs$ CrearItUni(robots(c))}
  [\Complejidad{1}]
  [Crea el iterador de robots.]
	
	\InterfazFuncion{Actual}{\In{it}{itRURs}}{rur}
  %[$c_0 \equiv c$ $\wedge$ $e$ $\in$ estaciones($c_0$)]
  {res $\igobs$ Actual(it)}
  [\Complejidad{1}]
  [Devuelve el actual del iterador de robots.]
	
	\InterfazFuncion{Avanzar}{\In{it}{itRURs}}{itRURs}
  %[$c_0 \equiv c$ $\wedge$ $e$ $\in$ estaciones($c_0$)]
  {res $\igobs$ Avanzar(it)}
  [\Complejidad{1}]
  [Avanza el iterador de robots.]
	
	\InterfazFuncion{HayMas?}{\In{it}{itRURs}}{bool}
  %[$c_0 \equiv c$ $\wedge$ $e$ $\in$ estaciones($c_0$)]
  {res $\igobs$ HayMas?(it)}
  [\Complejidad{1}]
  [Se fija si hay mas elementos en el iterador de robots.]
	
  
\end{Interfaz}

\subsection{Representacion}

\begin{Representacion}

%DESCRIPCION

\bigskip
\begin{Estructura}{dcnet}[e\_dc]
	\begin{Tupla}[e\_dc]
		\tupItem{red}{red}
		\tupTupItem{\\MasEnviante}{\TipoVariable{tupla}$($\ignorespaces
			\emph{compu}: \TipoVariable{compu}, 
			\emph{enviados}: \TipoVariable{nat}$)$}
		\tupTupItem{\\CompYPaq}{\TipoVariable{DiccString}$($\ignorespaces
			\emph{compu}: \TipoVariable{compu},
			\TipoVariable{tupla}$($\ignorespaces
			\emph{MasPriori}:{DiccRapido}$($\ignorespaces
			\emph{prioridad} :{nat},
			\emph{PaqdePriori}:{conj$($paquete$)$}
			 $)$,
			\emph{PaqYCam}:{DiccRapido} $($\ignorespaces
			\emph{idpaq}:{nat},
			\TipoVariable{tupla}$($\ignorespaces
			\emph{CamRecorrido}:{secu$($compu$)$,
			\emph{Origen}:{compu},
			\emph{Destino}:{compu},
			\emph{Prioridad}:{nat}}$)$,
			\emph{Enviados}:{nat}$))$}
	
	\end{Tupla}
\end{Estructura}

\subsection{InvRep y Abs}

\begin{enumerate}
 \item{El conjunto de estaciones de 'mapa' es igual al conjunto con todas las claves de 'RURenEst'.}
 \item{La longitud de 'RURs' es mayor o igual a '\#RURHistoricos'.}
 \item{Todos los elementos de 'RURs' cumplen que su primer componente ('id') corresponde con su posicion en 'RURs'. 
       Su Componente 'e' es una de las estaciones de 'mapa', su componente 'esta?' es true si y solo si hay estaciones tales que su 
       valor asignado en 'uniones' es igual a su indice en 'RURs'. Su Componente 'inf' puede ser mayor a cero solamente si hay algun elemento en 
       'sendEv' tal que sea false. Cada elemento de 'sendEv' es igual a verificar 'carac' con la estriccion obtenida al buscar el 
       elemento con la misma posicion en la secuencia de restricciones de 'mapa'.}
 \item{Cada valor contenido en la cola del significado de cada estacion de las claves de 'uniones' pertenecen unicamente a la cola asociada a dicha estacion y a ninguna otra de las colas asociadas a otras estaciones. Y cada uno de estos valores es menor a '\#RURHistoricos' y mayor o igual a cero. Ademas la componente 'e' del elemento de la posicion igual a cada valor de las colas asociadas a cada estacion, es igual a la estacion asociada a la cola a la que pertenece el valor.}

\end{enumerate}


\Rep[e\_cr][c]{
	claves(c.RURenEst) $=$ estaciones(c.mapa) $\wedge$ \hfill1 \newline
	\#RURHistoricos $\leq$ Long(c.RURs) $\yluego$
	($\forall$ i:Nat, t:<id:Nat, esta?:Bool, e:String, \hfill2 \newline
	inf:Nat, carac:Conj(Tag), sendEv: ad(Bool)>) \newline
	(i<\#RURHistoricos $\yluego$ ElemDeSecu(c.RURs, i) = t $\impluego$ (t.e $\in$ estaciones(c.mapa) \hfill3 \newline
	$\wedge$ t.id $=$ i $\wedge$ tam(t.sendEv) $=$ long(Restricciones(c.mapa)) $\wedge$ \newline
	(t.inf > 0 $\Rightarrow$ ($\exists$ j:Nat) (j < tam(t.sendEv) $\yluego$ $\neg$ (t.sendEv[j]))) $\wedge$ \newline
	(t.esta? $\Leftrightarrow$ ($\exists$ e1: String) (e1 $\in$ claves(c.RUREnEst) $\yluego$ estaEnColaP?(obtener(e1, c.RUREnEst), t.id))) \newline
	$\wedge$ ($\forall$ h : Nat) (h < tam(t.sendEv) $\impluego$ \newline
	t.sendEv[h] = verifica?(t.carac, ElemDeSecu(Restricciones(c.mapa), h))))) $\yluego$ \newline
	($\forall$ e1, e2: String)(e1 $\in$ claves(c.RUREnEst) $\wedge$ e2 $\in$ claves(c.RUREnEst) $\wedge$ e1 $\neq$ e2 $\impluego$ \hfill4 \newline
	($\forall$ n:Nat)(estaEnColaP?(obtener(e1, c.RUREnEst), n) $\Rightarrow$ $\neg$ estaEnColaP?(obtener(e2, c.RUREnEst), n) $\wedge$
	n < \#RURHistoricos $\yluego$ ElemDeSecu(c.RURs, n).e $=$ e1))
	}
	
	\vspace{3em}
	
	\tadOperacion{estaEnColaP?}{ColaPri, Nat}{Bool}{}
	\vspace{1em}
	\tadAxioma{estaEnColaP?(cp, n)}{
	\IF vacia?(cp) 
	THEN false 
	ELSE 
	      {\IF desencolar(cp) = n 
	      THEN true 
	      ELSE estaEnColaP?(Eliminar(cp, desencolar(cp)), n) 
	      FI}
	FI}
	
	\vspace{3em}
	
	\Abs[e\_cr]{ciudad}[c]{u}{
		\\ c.\#RURHistoricos = ProximoRUR(U) $\wedge$ c.mapa = mapa(u) $\yluego$
		\\ robots(u) = RURQueEstan(c.RURs) $\yluego$ 
		\\ ($\forall$ n:Nat) (n $\in$ robots(u) $\impluego$ estacion(n,u) = c.RURs[n].e $\wedge$
		\\ tags(n,u) = c.RURs[n].carac $\wedge$ \#infracciones(n,u) = c.RURs[n].inf)}
		
	\vspace{3em}
	\tadOperacion{RURQueEstan}{secu(tupla)}{Conj(RUR)}{}
	\vspace{1em}
	tupla es <id:Nat, esta?:Bool, inf:Nat, carac:Conj(tag), sendEv:arreglo dimensionable(bool)>
	\vspace{1em}
	\tadAxioma{RURQueEstan(s)}{
	\IF vacia?(s)
	THEN $\emptyset$
	ELSE 
	      {\IF $\Pi_2$(prim(fin(s)))
	      THEN {$\Pi_1$(prim(fin(s)))} $\cup$ RURQueEstan(fin(s))
	      ELSE RURQueEstan(fin(s))
	      FI}
	FI}
	
\vspace{3em}

\begin{Estructura}{it}[e\_it]
	\begin{Tupla}[e\_it]
		\tupItem{i}{nat}
		\tupItem{maxI}{nat}
		\tupItem{ciudad}{puntero(ciudad)}
	\end{Tupla}
\end{Estructura}

\Rep[e\_it][it]{
	it.i $\leq$ it.maxI $\wedge$ maxI $=$ ciudad.\#RURHistoricos
}

\Abs[e\_it]{itUni($\alpha$)}[u]{it}{
	(HayMas?(u) $\yluego$ Actual(u) = ciudad.RURs[it.i] $\wedge$ Siguientes(u, $\emptyset$) = VSiguientes(ciudad, it.i++, $\emptyset$) $\vee$ ($\neg$HayMas?(u))
}

\vspace{2em}
	
\tadOperacion{Siguientes}{itUni u, conj(RURs) cr}{conj(RURs)}{}
														
\vspace{1em}

\tadAxioma{Siguientes(u, cr)}{\IF HayMas(u)? THEN Ag(Actual(Avanzar(u)), Siguientes(Avanzar(u), cr)) ELSE Ag($\emptyset$, cr) FI}
		
\vspace{1em}

\tadOperacion{VSiguientes}{ciudad c, Nat i, conj(RURs) cr}{conj(RURs)}{}
														
\vspace{1em}

\tadAxioma{VSiguientes(u, i, cr)}{\IF i < c.\#RURHistoricos THEN Ag(c.RURs[i], VSiguientes(u, i++, cr))) ELSE Ag($\emptyset$, cr) FI}

\vspace{2em}

\end{Representacion}

%tupla<mapa:mapa, robEnEst: dicctrie(estacion, conj(puntero(RUR))), robots: conj(RUR)>

\subsection{Algoritmos}

\begin{Algoritmos}

	\begin{Algoritmo}{iRed}{\In {d}{dcnet}}{red}
	{
		\State $res$ $\gets$ ($d.red$) \ComplejidadDer{1}
	}
	{\Complejidad{1}}
	{}
	
	\end{Algoritmo}
	
	\begin{Algoritmo}{iCaminoRecorrido}{\In {d}{dcnet},\In {p}{paquete}}{secu(compu)}
	{
		\State var $it$ $\gets$ computadoras(d.red) \ComplejidadDer{1}
		\While {HaySiguiente($it$)}   \ComplejidadDer{Cardinal(pc)}
		\If {def?(p.id, significado(Siguiente($it$), CompYPaq.d).PaqYCam)}	\ComplejidadDer{|Siguiente($it$) + log_2(N)}
		\State $res$ $\gets$ obtener(p.id, significado(Siguiente($it$), CompYPaq.d).PaqYCam).CamRecorrido	\ComplejidadDer{|Siguiente($it$) + log_2(N)} 		
		\EndIf
		\State Avanzar($it$)  \ComplejidadDer{1}
		\EndWhile
	}
	{\Complejidad{|compu| }}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iCantidadEnviados}{\In {d}{dcnet}, \In {c}{compu}}{nat}
	{
		\State $res$ $\gets$ Significado(c,d.CompYPaq).Enviados  \ComplejidadDer{|c|}
	}
	{\Complejidad{1}}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{enEspera}{\In {d}{dcnet}, \In {c}{compu}}{itPaquete)}
	{
		\State $res$  $\gets$ claves(Significado(c , d.CompYPaq).PaqYCam) \ComplejidadDer{1}
	}
	{\Complejidad{1}}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iIniciarDCNet}{\In {r}{red}, \Inout {d}{dcnet}}{}
	{
		\State d.red $\gets$ r \ComplejidadDer{1}
		\State  var $it$ $\gets$ computadoras(red) \ComplejidadDer{1}
		\State d.MasEnviante $\gets$ tupla(Siguiente($it$),0) \ComplejidadDer{1}
		\State d.CompyPaq $\gets$ Vacio() \ComplejidadDer{1}
		\While {HaySiguiente($it$)}  \ComplejidadDer{1}
		\State Definir(d.CompyPaq, Siguiente($it$), tupla(Vacio(), Vacio(), 0) \ComplejidadDer{1}
		\State Avanzar($it$) \ComplejidadDer{1}
		\EndWhile
		
	}
	{\Complejidad{1}}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iCrearPaquete}{\In {p}{rur}, \Inout {d}{dcnet}}{}
	{
		\If {def?(p.prioridad,significado(d.CompYPaq. p.origen).MasPriori)}	\ComplejidadDer{1}
			\State Definir(significado($d$.CompYPaq., $p$.origen).MasPriori, $p$.prioridad, Agregar(Vacio(),$p$))
		\Else {Definir(significado(d.CompYPaq., p.origen).MasPriori, p.prioridad,Agregar(significado(significado(d.CompYPaq., p.origen).MasPriori, p.prioridad)} \ComplejidadDer{1}
		\EndIf
		
		\State definir(p,significado(d.CompYPaq. p.origen).PaqYCam),AgregarAtras(<>,p.origen)	\ComplejidadDer{1}
		
		
		}
	{\Complejidad{1}}
	{}
	\end{Algoritmo}
	
	
	
	\begin{Algoritmo}{iAvanzarSegundo}{\Inout {d}{dcnet}}{}
	{
		\State var $it$ $\gets$ computadoras(red) \ComplejidadDer{1}
		\State var aux $\gets$ Vacia()
		\While {HaySiguiente($it$)}	\ComplejidadDer{1}
		\If {$\neg$ Vacio?(significado(d.CompYPaq,Siguiente($it$).MasPriori)}
			\State var $it2$ $\gets$ crearIt(DameMAx(d.CompYPaq,Siguiente($it$).MasPriori)\ComplejidadDer{1}
			\State AgregarAdelante(aux,Siguiente(tupla(paq: $it2$,pcant: $it$))
			
			\State Borrar(significado(d.CompYPaq,Siguiente($it$).PaqYCam , $it$.id)
			\State EliminarSiguiente($it2$)
			\State	significado(d.CompYPaq, Siguiente($it$)).Enviados ++ \ComplejidadDer{1}
		\If {significado(d.CompYPaq, Siguiente ($it$).Enviados > d.MasEnviante.enviados }	\ComplejidadDer{1}
			\State d.MasEnviante $\gets$ tupla(Siguiente($it$), significado(d.CompYPaq,Siguiente($it$).Enviados )	\ComplejidadDer{1}
		\EndIf		
		\EndIf
		\State Avanzar($it$)
		\EndWhile
		\State var $it3$ $\gets$ crearIt(aux)
		\While {HaySiguiente($it3$)}
			\If {def?(($it3$.paq).prioridad,significado(d.CompYPaq,CaminoMinimo(d.red, $it3$.pcant,$it3$.destino).MasPriori)}	\ComplejidadDer{1}
			
			\State {Definir(significado(d.CompYPaq., CaminoMinimo(d.red, $it3$.pcant,$it3$.destino).MasPriori, $it3$.paq.prioridad,Agregar(significado(significado(d.CompYPaq., CaminoMinimo(d.red, $it3$.pcant,$it3$.destino)).MasPriori, $it3$.paq.prioridad)} \ComplejidadDer{1}
		
		
		 \Else Definir(significado(d.CompYPaq., ($it3$.paq).destino).MasPriori, $it3$.prioridad, Agregar(Vacio(),$it3$.paq))
		\EndIf
		
		\State definir(p,significado(d.CompYPaq. p.origen).PaqYCam),AgregarAtras(CaminoRecorrido(d, $it3$.paq) ,CaminoMinimo(d.red, $it3$.pcant,$it3$.destino))	\ComplejidadDer{1}
		\State EliminarSiguiente($it3$)
		\State Avanzar($it3$)
		\EndWhile
		
		}
	{\Complejidad{1}}
	{}
	\end{Algoritmo}
	
	
	
	

	%\Algoritmo{IENTRAR}{\In {ts}{conj(tags)}, \In {e}{estación}, \Inout {c}{ciudad}}{}{
		%\State e\_ciudad.cRUR $\gets$ e\_ciudad.cRUR + 1 \ComplejidadDer{1}
		%\State var sendas $\gets$ EVALUARSENDAS(ts, e\_ciudad.m) \ComplejidadDer{S \cdot R}
		%\State var nRUR $\gets$ tupla(e\_ciudad.RURs, e, 0, ts, sendas) \ComplejidadDer{1}
		%\State AGREGARATRAS(e\_ciudad.RURs, nRUR) \ComplejidadDer{1}
		%\State obtEst = \&(SIGNIFICADO(e.RUREnEst, e)) \ComplejidadDer{|e|}
		%\State ENCOLAR(obtEst, tupla(e\_ciudad.cRUR, 0)) \ComplejidadDer{log\ N}
	%}{\Complejidad{|e| + S \cdot R + log\ N}}{
	%Justificacion.
	%}
	%
	%\newpage
	%
	%\Algoritmo{IMOVER}{\In {u}{nat}, \In {e2}{estación}, \Inout {c}{ciudad}}{}{
		%\State var est $\gets$ OBTENERCOLAEST(c.RUREnEst, c.RURs[u].e) \ComplejidadDer{|e1|}
		%\State SACARRUR(est, u) \ComplejidadDer{log\ N_{e1}}
		%\State INFRACCIONO?(u, NROCONEXION(c.RURs[u].e, e2) \ComplejidadDer{|e1| + |e2|}
		%\State MODIFICARRUR(u) \ComplejidadDer{1}
		%\State est $\gets$ OBTENERCOLAEST(c.RUREnEst, e2) \ComplejidadDer{|e2|}
		%\State METERRUR(est, u) \ComplejidadDer{log\ N_{e2}}
	%}{\Complejidad{|e1| + |e2| + log\ N_{e1} + log\ N_{e2}}}{
		%$\Complejidad{|e1|} + \Complejidad{|e2|} + \Complejidad{log\ N_{e1}} + 
		%\Complejidad{log\ N_{e2}} + \Complejidad{|e1| + |e2|} + \Complejidad{1} =$\\
		%$2 * \Complejidad{|e1| + |e2|} + \Complejidad{log\ N_{e2} + log\ N_{e1}} =$\\
		%$\Complejidad{|e1| + |e2|} + \Complejidad{log\ N_{e2} + log\ N_{e1}} =$\\
		%$\Complejidad{|e1| + |e2| + log\ N_{e2} + log\ N_{e1}}$
	%}

\end{Algoritmos}