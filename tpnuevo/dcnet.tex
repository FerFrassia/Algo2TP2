\section{DCNet}

\subsection{Interfaz}

\begin{Interfaz}
  
  %\textbf{parámetros formales}\hangindent=2\parindent\\
  %\parbox{1.7cm}{\textbf{géneros}} \\
  %\parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    %\InterfazFuncion{Verifica?}{\In{c}{conj(tag)}, \In{r}{rest}}{$\alpha$}
    %{$res \igobs a$}
    %[$\Theta(copy(a))$]
    %[función de copia de $\alpha$'s]
  %}

  \textbf{se explica con}: \tadNombre{DCNet}.

  \textbf{géneros}: \TipoVariable{dcnet}.

  \Titulo{Operaciones básicas de DCNet}
	

  \InterfazFuncion{Red}{\In {d}{dcnet}}{red}
  %[ACA VA EL PRE (SI LO HUBIERA)]
  {$res \igobs$ red($d$)}
  [\Complejidad{1}]
  [Devuelve la red del dcnet.]
  
  \InterfazFuncion{CaminoRecorrido}{\In {d}{dcnet}, \In{p}{paquete} }{secu(compu)}
  [$p$ $\in$ paqueteEnTransito?($d,p$)]
  {$res \igobs$ caminoRecorrido($d,p$))}
  [\Complejidad{n*log_2 (k)}]
  [Devuelve una secuencia con las computadoras por las que paso el paquete.]
  
  \InterfazFuncion{cantidadEnviados}{\In {d}{dcnet}, \In {c}{compu}}{nat}
  [$c$ $\in$ computadoras(red($d$))]
  {$res \igobs$ cantidadEnviados($d,c$)}
  [\Complejidad{|$c$.id|}]
  [Devuelve la cantidad de paquetes que fueron enviados desde la computadora.]
  
  \InterfazFuncion{enEspera}{\In {d}{dcnet}, \In {c}{compu}}{itPaquete}
  [$c$ $\in$ computadoras(red($d$))]
  {$res \igobs$ enEspera($d,c$)}
  [\Complejidad{|$c$.id|}]
  [Devuelve los paquetes que se encuentran en ese momento en la computadora.]
  
  \InterfazFuncion{IniciarDCNet}{\In {r}{red}}{dcnet}
  %[ACA VA EL PRE (SI LO HUBIERA)]
  {$res \igobs$ iniciarDCNet($r$)}
  [\Complejidad{N*L}]
  [Inicia un dcnet con la red y sin paquetes.]

  \InterfazFuncion{CrearPaquete}{\In {p}{paquete}, \Inout {d}{dcnet}}{}
  [$d_0 \equiv d$ $\wedge$ $\neg$ (($\exists$ $p_1$: paquete)(paqueteEnTransito($s,p_1$) $\wedge$ id($p_1$) $=$ id($p$)) $\wedge$ origen($p$) $\in$ computadoras(red($d$))$\yluego$ destino($p$) $\in$ computadoras(red($d$))$\yluego$ hayCamino?(red($d$,origen($p$),destino($p$))  ]
  {$res \igobs$ iniciarDCNet($r$)}
  [\Complejidad{L+log_2(k)}]
  [Agrega el paquete al dcnet.]
  
  \InterfazFuncion{AvanzarSegundo}{\Inout {d}{dcnet}}{}
  [$d_0 \equiv d$ ]
  {$d$ $\igobs$ avanzarSegundo($c_0$)}
  [\Complejidad{N*(L+log_2(k)}]
  [El paquete de mayor prioridad de cada computadora avanza a su proxima computadora siendo esta la del camino mas corto.]
  
  
  \InterfazFuncion{PaqueteEnTransito?}{\In {d}{dcnet}, \In {p}{paquete}}{bool}
  [ ]
  {$res$ $\igobs$ paqueteEnTransito?($d$,$p$)}
  [\Complejidad{N*log_2(k)}]
  [Devuelve si el paquete esta o no en alguna computadora del sistema.]
  
  
  \InterfazFuncion{LaQueMasEnvio}{\In {d}{dcnet)}}{compu}
  []
  {$res$ $\igobs$ laQueMasEnvio($d$)}
  [\Complejidad{1}]
  [Devuelve la computadora que mas paquetes envio.]
	
	\Titulo{Operaciones del iterador}
  
\end{Interfaz}

\subsection{Representacion}

\begin{Representacion}

%DESCRIPCION
El dcnet esta representado con una tupla en la cual: vamos a tener  la red (en d.red) con la que se inicia el dcnet(pasada por referencia), una tupla que tiene la computadora que mas paquetes envio y cuantos ha enviado (en d.MasEnviante). Luego, un diccionario String (d.CompYPaq) cuyas claves son las computadoras de la red  y su significado es una tupla. Esta tupla tiene tres componentes: un Diccionario Rapido (MasPriori) cuya clave es un natural (prioridad, osea la prioridad del paquete) y su significado es un conj(paquete) (PaqdePriori), luego otro Diccionario Rapido (PaqYCam) cuya clave es el paquete (habiendo establecido previamente que la relacion de orden entre paquetes es por id) y su significado es una secu(compu) (CamRecorrido), finalmente un natural (Enviados) que representa la cantidad de paquetes enviados por la computadora.



\bigskip
\begin{Estructura}{dcnet}[e\_dc]
	\begin{Tupla}[e\_dc]
		\tupItem{red}{red}
		\tupTupItem{\\MasEnviante}{\TipoVariable{tupla}$($\ignorespaces
			\emph{compu}: \TipoVariable{compu}, 
			\emph{enviados}: \TipoVariable{nat}$)$}
		\tupTupItem{\\CompYPaq}{\TipoVariable{DiccString}$($\ignorespaces
			\emph{compu}: \TipoVariable{compu},
			\TipoVariable{tupla}$($\ignorespaces
			\emph{MasPriori}:{DiccRapido}$($\ignorespaces
			\emph{prioridad} :{nat},
			\emph{PaqdePriori}:{conj$($paquete$)$}
			 $)$,
			\emph{PaqYCam}:{DiccRapido} $($\ignorespaces
			\emph{paq}:{paquete},
			\emph{CamRecorrido}:{secu($compu$)}$)$, 
			\emph{Enviados}:{nat})
		
			}
			
	
	\end{Tupla}
\end{Estructura}

\subsection{InvRep y Abs}

\begin{enumerate}
 \item{El conjunto armado por las ips de las computadoras de 'red' es igual al conjunto con todas las claves de 'CompYPaq'.}
 \item{Para toda compu (c1) perteneciente a las claves de 'CompYPaq' cuyo significado.enviados es (e1), d.MasEnviante.enviados (e2) es mayor o igual a e1. Luego, d.MasEnviante.compu esta definida en 'CompYPaq' y su significado es e2. }
 \item{si una computadora pertenece a un significado de 'PaqYCam', entonces pertenece a claves de 'CompYPaq'}
 \item{La union de todos los significados de MasPriori es igual a las claves de 'PaqYCam'}
 \item{si un paquete (paq) pertenece al significado de una prioridad (pri) en el diccionario MasPriori, entonces la prioridad de paq es pri}
 \item{no existen claves en el diccionario 'MasPriori' con significado vacio.}
 \item{si un paquete (p1) esta definido en 'PaqYCam' como significado de una computadora (c1) en el diccionario 'CompYPaq', entonces p1 no puede estar definido en 'PaqYCam' como significado de una computadora (c2), siendo c1 y c2 distintas.}
 \item{si un paquete (p1) esta definido en 'PaqYCam' como significado de una computadora(c1) en el diccionario 'CompYPaq', entonces la ultima componente de su significado (osea, 'CamRecorrido') es c1}


\end{enumerate}


\Rep[e\_dc][d]{claves(d.CompYPaq) $=$ ipCompus(computadoras(d.red))$\wedge$ \hfill1 \newline
	($\forall$ c:compu)(c.ip $\in$ claves(d.CompYPaq))\newline
	(obtener(c.ip,d.CompYPaq).enviados $\leq$ (d.MasEnviante).enviados $\wedge$ def?(d.MasEnviante).compu, d.CompYPaq) $\yluego$ \newline obtener(d.MasEnviante.compu, d.CompYPaq).enviados = (d.MasEnviante).enviados)\hfill2 \newline
	($\forall$ $c_2$:compu, p:paquete)(esta?($c_2$,obtener(p,obtener(c.ip, d.CompYPaq).PaqYCam)) $\Rightarrow$  def?($c_2$, d.CompYPaq) \hfill3 \newline
	$\wedge$ juntarSignificados(obtener(c.ip,d.CompYPaq).MasPriori,claves(obtener(c.ip,d.CompYPaq).MasPriori)
 $=$ claves(obtener(c.ip,d.CompYPaq).PaqYCam)	\hfill4 \newline
 ($\forall$ pr:Nat,p:paquete)(def?(pr,Obtener(c.ip,d.CompYPaq).MasPriori) $\yluego$ \newline 
 p $\in$ obtener(pr,c.ip,d.CompYPaq).MasPriori)$\rightarrow$ pr = p.prioridad) $\wedge$ \hfill5 \newline
 ($\forall$ pr:Nat) (Def?(pr, Obtener(c.ip, d.CompYPaq).MasPriori) $\impluego$  $\neg$ $\emptyset$? Obtener(pr, Obtener(c.ip, d.CompYPaq).MasPriori)) $\wedge$ \hfill6 \newline
 ($\forall$ p1:paquete, c2:computadora) (Def?(p, Obtener(c.ip, d.CompYPaq).PaqYCam) $\wedge$ def?(c2.ip, d.CompYPaq) $\impluego$ $\neg$def?(p, Obtener(c2.ip, d.CompYPaq).PaqYCam)  $\wedge$ \hfill7 \newline
 ($\forall$ p:paquete) (def?(p, obtener(c.ip, d.CompYPaq).PaqYCam) $\impluego$ ult(obtener(p, obtener(c.ip, d.CompYPaq).PaqYCam)) = c)	\hfill8
	 }
	
	\vspace{3em}
	
	\tadOperacion{ipCompus}{Conj(compu)}{Conj(string)}{}
	\tadOperacion{juntarSignificados}{Dicc , Conj}{Conj}{}
	
	\vspace{1em}
	\tadAxioma{juntarSignificados(dic, cl)}{
	\IF vacia?(cl) 
	THEN $\emptyset$ 
	ELSE 
	      obtener(DameUno(cl),dic) $\cup$ juntarSignificados(dic, SinUno(cl))
	FI}	
	\tadAxioma{ipCompus(cc)}{
	\IF vacia?(cp) 
	THEN $\emptyset$ 
	ELSE 
	      {Agregar(DameUno(cc).ip,ipCompus(SinUno(cc)))}
	FI}
	
	
	\vspace{3em}
	
	\Abs[e\_dc]{dcnet}[e]{d}{
		\\ red(d) = e.red $\yluego$
		\\($\forall$ p:paquete, c:compu) (paqueteEnTransito?(d, p) $\impluego$ (def?(c.ip, e.CompYPaq $\yluego$ def?(p, obtener(c.ip, e.CompYPaq).PaqYCam) $\impluego$ obtener(p, obtener(c.ip, e.CompYPaq).PaqYCam) = caminoRecorrido(d, p)))
		\\($\forall$ c:compu) (c $\in$ computadoras(red(d)) $\impluego$ ((def?(c.ip, e.CompYPaq) $\impluego$ obtener(c.ip, e.CompYPaq).Enviados = cantidadEnviados(d, c)) $\wedge$ (def?(c.ip, e.CompYPaq) $\impluego$ claves(obtener(c.ip, e.CompYPaq).PaqYCam) = enEspera(d, c))))
		
		 }
		
\vspace{3em}

\end{Representacion}

%tupla<mapa:mapa, robEnEst: dicctrie(estacion, conj(puntero(RUR))), robots: conj(RUR)>

\subsection{Algoritmos}

\begin{Algoritmos}




	\begin{Algoritmo}{iRed}{\In {d}{dcnet}}{red}
	{
		\State $res$ $\gets$ ($d$.red) \ComplejidadDer{1}
	}
	{\Complejidad{1}}
	{}
	
	\end{Algoritmo}
	
	
	
	
	\begin{Algoritmo}{iCaminoRecorrido}{\In {d}{dcnet},\In {p}{paquete}}{secu(compu)}
	{
		\State var $it$ $\gets$ \NombreFuncion {creaIt}(d.CompYPaq) \ComplejidadDer{N}
		\State var $esta$: bool $\gets$ false \ComplejidadDer{1}
		\While {\NombreFuncion {HaySiguiente}($it$) $\wedge$ $\neg$ esta}   \ComplejidadDer{n}
			\State var $diccpaq$:diccRapido  $\gets$  ((\NombreFuncion{Siguiente}($it$)).significado).PaqYCam	\ComplejidadDer{1}
			\If {\NombreFuncion {def?}($p$,$diccpaq$)}	\ComplejidadDer{log_2(k)}
				\State $esta$ $\gets$ true \ComplejidadDer{1}
				\State $res$ $\gets$ \NombreFuncion {obtener}($p$, $diccpaq$)	\ComplejidadDer{log_2(k)} 		
			\EndIf
			\State \NombreFuncion {Avanzar}($it$)  \ComplejidadDer{1}
		\EndWhile
	}
	{\Complejidad{N* log_2(k) }Donde N es la cantidad de computadoras en la red, y k la cantidad maxima de paquetes que hay en una computadora.}
	{$\Complejidad{1} + \Complejidad{1} + n* (\Complejidad{1} + \Complejidad{log_2(k)} + \Complejidad{1} + \Complejidad{log_2(k)} =$\\
	$\Complejidad{2} + n*(2 \Complejidad{ log_2(k)}) =$ \\
	 $\Complejidad{n* (log_2(k)) }$
	}
	\end{Algoritmo}
	
	
	
	
	
	\begin{Algoritmo}{iCantidadEnviados}{\In {d}{dcnet}, \In {c}{compu}}{nat}
	{
		\State $res$ $\gets$ \NombreFuncion {obtener}($c$.id,$d$.CompYPaq).Enviados  \ComplejidadDer{L}
	}
	{\Complejidad{L} Siendo L la longitud de el ID de $c$}
	{}
	\end{Algoritmo}
	
	
	
	
	\begin{Algoritmo}{iEnEspera}{\In {d}{dcnet}, \In {c}{compu}}{itPaquete)}
	{
		\State $res$  $\gets$ \NombreFuncion {claves}(\NombreFuncion {obtener}($c$.id, $d$.CompYPaq).PaqYCam) \ComplejidadDer{L}
	}
	{\Complejidad{|L|} Siendo L la longitud  del ID de $c$}
	{}
	\end{Algoritmo}
	
	
	
	
	
	
	\begin{Algoritmo}{iIniciarDCNet}{\In {r}{red}, \Inout {d}{dcnet}}{}
	{
		\State $d$.red $\gets$ r \ComplejidadDer{NOSE}
		\State  var $it$ $\gets$ \NombreFuncion {computadoras}(red) \ComplejidadDer{1}
		\State $d$.MasEnviante $\gets$ tupla(\NombreFuncion {Siguiente}($it$),0) \ComplejidadDer{1}
		\State $d$.CompyPaq $\gets$ Vacio() \ComplejidadDer{1}
		\While {\NombreFuncion{HaySiguiente}($it$)}  \ComplejidadDer{N}
			\State \NombreFuncion {Definir}(\NombreFuncion {Siguiente}($it$).id, tupla(\NombreFuncion {Vacio}(),\NombreFuncion {Vacio}(), 0), $d$.CompyPaq) \ComplejidadDer{L + 1 + 1}
			\State \NombreFuncion {Avanzar}($it$) \ComplejidadDer{1}
		\EndWhile
		
	}
	{\Complejidad{N*L} Siendo N la cantidad de computadoras en la red y L el ID mas largo de ellas.}
	{$\Complejidad{1} + \Complejidad{1}+ \Complejidad{1} + \Complejidad{1} + N * \Complejidad{L +1 +1} + \Complejidad{1} =$ \\
	$\Complejidad{N*L}$ }
	\end{Algoritmo}
	
	
	
	
	
	
	\begin{Algoritmo}{iCrearPaquete}{\In {p}{paquete}, \Inout {d}{dcnet}}{}
	{
	
		\State var $diccprio$: diccRapido $\gets$ \NombreFuncion {obtener}($p$.origen, $d$.CompYPaq).MasPriori)	\ComplejidadDer{L}
		\State var $dicccam$: diccRapido $\gets$ \NombreFuncion {obtener}($p$.origen, $d$.CompYPaq).PaqYCam) \ComplejidadDer{L}
		\If {$\neg$ \NombreFuncion {def?}(p.prioridad, $diccprio$)}	\ComplejidadDer{log_2(k)}
			\State \NombreFuncion {Definir}($p$.prioridad,\NombreFuncion {Agregar}(\NombreFuncion {Vacio}(), $p$), $diccprio$)	\ComplejidadDer{log_2(k)}
		\Else 
			\State \NombreFuncion {Definir}($p$.prioridad,\NombreFuncion{Agregar}(\NombreFuncion {obtener}($p$.prioridad, $diccprio$), $p$), $diccprio$	\ComplejidadDer{log_2(k)}
		\EndIf
		
		\State \NombreFuncion{definir}($p$, $dicccam$, \NombreFuncion {AgregarAtras}(<>,p.origen)	\ComplejidadDer{log_2(k)}
		
		
		}
	{\Complejidad{L+ log_2(k)} Donde L es la longitud de la computadora de origen del paquete, y k la cantidad de paquetes que EnEspera en esa computadora.}
	{$ \Complejidad{L} + \Complejidad{L} + \Complejidad{log_2(k)} + \Complejidad{log_2(k)} + \Complejidad{log_2(k)} + \Complejidad{log_2(k)} =$ \\
	$2*\Complejidad{L} + 4*\Complejidad{log_2(k)} =$\\
	$\Complejidad{L + log_2(k) }$}
	\end{Algoritmo}
	
	
	
	\begin{Algoritmo}{iAvanzarSegundo}{\Inout {d}{dcnet}}{}
	{
		\State var $it$ $\gets$ \NombreFuncion {computadoras}(red) \ComplejidadDer{1}
		\State var aux $\gets$ \NombreFuncion {Vacia}()	\ComplejidadDer{1}
		\While {\NombreFuncion {HaySiguiente}($it$)}	\ComplejidadDer{N}
		
			\State var $diccprio$: diccRapido $\gets$ \NombreFuncion {obtener}( \NombreFuncion{Siguiente}($it$).id, $d$.CompYPaq).MasPriori)	\ComplejidadDer{L}
		\State var $dicccam$: diccRapido $\gets$ \NombreFuncion {obtener}(\NombreFuncion{Siguiente}($it$).id, $d$.CompYPaq).PaqYCam) \ComplejidadDer{L}
			\If {$\neg$ \NombreFuncion {Vacio?}($diccprio$)} \ComplejidadDer{1}
				\State var $paq$: paquete $\gets$ \NombreFuncion{Primero}(\NombreFuncion {obtener}(\NombreFuncion {ClaveMax}($diccprio$), $diccprio$)) \ComplejidadDer{log_2(k)+1+1}
				\State \NombreFuncion {AgregarAdelante}(aux, tupla(paq: $paq$,pcant: $it$.id, camrecorrido: \NombreFuncion{obtener}($paq$, $dicccam$)) \ComplejidadDer{1+ log_2(k)}
			
				\State \NombreFuncion {Eliminar}(\NombreFuncion{obtener}(\NombreFuncion {ClaveMax}($diccprio$), $diccprio$), $paq$) \ComplejidadDer{log_2(k)+log_2(k)+1}%elimino el primero entonces es o 1( porque paq era el primero)
				\If {\NombreFuncion{EsVacio?}(\NombreFuncion{obtener}(\NombreFuncion {ClaveMax}($diccprio$), $diccprio$)} \ComplejidadDer{log_2(k)}
					\State \NombreFuncion{borrar}(\NombreFuncion {ClaveMax}($diccprio$), $diccprio$) \ComplejidadDer{log_2(k)}
				\EndIf
				\State \NombreFuncion{borrar}($paq$, $dicccam$) \ComplejidadDer{log_2(k)}
				
				
				\State	\NombreFuncion {obtener}(\NombreFuncion{Siguiente}($it$).id, $d$.CompYPaq).Enviados ++ \ComplejidadDer{L}
					\If {\NombreFuncion {obtener}(\NombreFuncion{Siguiente}($it$).id, $d$.CompYPaq).Enviados > ($d$.MasEnviante).enviados }	\ComplejidadDer{L+1}
						\State $d$.MasEnviante $\gets$ tupla(\NombreFuncion{Siguiente}($it$), \NombreFuncion {obtener}(\NombreFuncion{Siguiente}($it$).id, $d$.CompYPaq).Enviados )	\ComplejidadDer{L+1}
					\EndIf
							
				\EndIf
				
				\State \NombreFuncion{Avanzar}($it$) \ComplejidadDer{1}
		\EndWhile
		
		\State var $itaux$ $\gets$ \NombreFuncion{crearIt}(aux) \ComplejidadDer{1}
		\While {\NombreFuncion{HaySiguiente}($itaux$)} \ComplejidadDer{Nk}
		
			\State var $proxpc$: compu $\gets$ \NombreFuncion{Primero}(\NombreFuncion{Siguiente}(\NombreFuncion{CaminosMinimos}($d$.red, $itaux$.pcant, $itaux$.destino)) \ComplejidadDer{L_1 + L_2}
			
			\State var $diccprio$: diccRapido $\gets$ \NombreFuncion {obtener}( $proxpc$.id, $d$.CompYPaq).MasPriori)	\ComplejidadDer{L}
		\State var $dicccam$: diccRapido $\gets$ \NombreFuncion {obtener}($proxpc$.id, $d$.CompYPaq).PaqYCam) \ComplejidadDer{L}
			
			\If {$proxpc$ $\neq$ ($itaux$.paq).destino }
				\If {\NombreFuncion{def?}(($itaux$.paq).prioridad, $diccprio$)}	\ComplejidadDer{log_2(k)}
			
					\State 	var $mismaprio$: conj(paquetes) $\gets$ \NombreFuncion{Agregar}(\NombreFuncion {obtener}($it3$.paq.prioridad, $diccprio$), $it3$.paq)	\ComplejidadDer{log_2(k)}
					\State {\NombreFuncion{definir}(($it3$.paq).prioridad, $mismaprio$, $diccprio$)} \ComplejidadDer{log_2(k)}
		
		
		 		\Else 
		 			\State \NombreFuncion{Definir}($it3$.prioridad, \NombreFuncion{Agregar}(\NombreFuncion{Vacio}(),$it3$.paq), $diccprio$)\ComplejidadDer{log_2(k)}
				\EndIf
		
			\State \NombreFuncion{definir}($p$.paq,\NombreFuncion{AgregarAtras}($it3$.camrecorrido ,$proxpc$), $dicccam$)	\ComplejidadDer{log_2(k)}
			\EndIf
			\State \NombreFuncion{EliminarSiguiente}($it3$) \ComplejidadDer{1}
			\State \NombreFuncion{Avanzar}($it3$) \ComplejidadDer{1}
		\EndWhile
		
		}
	{\Complejidad{N*(L+log_2(k)} Donde N es la cantidad de computadoras, L la longitud del nombre mas largo de las computadoras, y k la cantidad mas grande de paquetes que tiene una computadora.}
	{$\Complejidad{1} + \Complejidad{1} + N * (\Complejidad{L} + \Complejidad{L} + \Complejidad{1} + \Complejidad{log_2(k)+1+1} + \Complejidad{1+log_2(k)} +\Complejidad{log_2(k)+log_2(k)+1} + \Complejidad{log_2(k)} + \Complejidad{log_2(k)} + \Complejidad{log_2(k)} + \Complejidad{L} + \Complejidad{L} + \Complejidad{L} + \Complejidad{1}) + N * (\Complejidad{L} + \Complejidad{L} + \Complejidad{log_2(k)} + \Complejidad{log_2(k)} +  \Complejidad{log_2(k)} + \Complejidad{log_2(k)} \Complejidad{log_2(k)} + \Complejidad{1} + \Complejidad{1} ) =$\\
	$N*(\Complejidad{5*L+5*log_2(k))} + N*\Complejidad{3*L+5*log_2(k)} =$\\
	$2N*(\Complejidad{L+log_2(k)} =$ \\
	 $\Complejidad{N*(L+log_2(k))$}
	 }
	\end{Algoritmo}
	
	
	\begin{Algoritmo}{iPaqueteEnTransito?}{\In {d}{dcnet}, \In {p}{paquete}}{bool}
	{
		\State var $it$  $\gets$ \NombreFuncion {crearIt}(\NombreFuncion {computadoras}(d.red) \ComplejidadDer{1}
		\State var $esta$: bool $\gets$ false \ComplejidadDer{1}
		\While{\NombreFuncion{HaySiguiente}($it$) $\wedge$ $\neg$ $esta$ }\ComplejidadDer{N}
			\State $esta$ $\gets$ \NombreFuncion{def?}(\NombreFuncion{obtener}(d.CompYPaq,$i$.id).PaqYCam , $p$) \ComplejidadDer{log_2(k)}
			\State \NombreFuncion{Avanzar}($it$)\ComplejidadDer{1}
		\EndWhile
			\State $res$ $\gets$ $esta$	\ComplejidadDer{1}
	
	
	}
	{\Complejidad{N*log(k)}Donde N es la cantidad de computadoras en la red y k la cantidad maxima de paquetes que hay en alguna compu.}
	{$\Complejidad{1} + \Complejidad{1} + N *( \Complejidad{log_2(k)} + \Complejidad{1}) + \Complejidad{1}=$\\
	$\Complejidad{3}+ N*(\Complejidad{log_2(k)}=$\\
	$\Complejidad{N*log_2(k)}$}
	\end{Algoritmo}
	
	
	
	\begin{Algoritmo}{iLaQueMasEnvio}{\In {d}{dcnet}}{compu}
	{
		\State $res$  $\gets$ ($d$.MasEnviante).compu \ComplejidadDer{1}
	}
	{\Complejidad{1}}
	{}
	\end{Algoritmo}
	
	
	
	
	

	%\Algoritmo{IENTRAR}{\In {ts}{conj(tags)}, \In {e}{estación}, \Inout {c}{ciudad}}{}{
		%\State e\_ciudad.cRUR $\gets$ e\_ciudad.cRUR + 1 \ComplejidadDer{1}
		%\State var sendas $\gets$ EVALUARSENDAS(ts, e\_ciudad.m) \ComplejidadDer{S \cdot R}
		%\State var nRUR $\gets$ tupla(e\_ciudad.RURs, e, 0, ts, sendas) \ComplejidadDer{1}
		%\State AGREGARATRAS(e\_ciudad.RURs, nRUR) \ComplejidadDer{1}
		%\State obtEst = \&(SIGNIFICADO(e.RUREnEst, e)) \ComplejidadDer{|e|}
		%\State ENCOLAR(obtEst, tupla(e\_ciudad.cRUR, 0)) \ComplejidadDer{log\ N}
	%}{\Complejidad{|e| + S \cdot R + log\ N}}{
	%Justificacion.
	%}
	%
	%\newpage
	%
	%\Algoritmo{IMOVER}{\In {u}{nat}, \In {e2}{estación}, \Inout {c}{ciudad}}{}{
		%\State var est $\gets$ OBTENERCOLAEST(c.RUREnEst, c.RURs[u].e) \ComplejidadDer{|e1|}
		%\State SACARRUR(est, u) \ComplejidadDer{log\ N_{e1}}
		%\State INFRACCIONO?(u, NROCONEXION(c.RURs[u].e, e2) \ComplejidadDer{|e1| + |e2|}
		%\State MODIFICARRUR(u) \ComplejidadDer{1}
		%\State est $\gets$ OBTENERCOLAEST(c.RUREnEst, e2) \ComplejidadDer{|e2|}
		%\State METERRUR(est, u) \ComplejidadDer{log\ N_{e2}}
	%}{\Complejidad{|e1| + |e2| + log\ N_{e1} + log\ N_{e2}}}{
		%$\Complejidad{|e1|} + \Complejidad{|e2|} + \Complejidad{log\ N_{e1}} + 
		%\Complejidad{log\ N_{e2}} + \Complejidad{|e1| + |e2|} + \Complejidad{1} =$\\
		%$2 * \Complejidad{|e1| + |e2|} + \Complejidad{log\ N_{e2} + log\ N_{e1}} =$\\
		%$\Complejidad{|e1| + |e2|} + \Complejidad{log\ N_{e2} + log\ N_{e1}} =$\\
		%$\Complejidad{|e1| + |e2| + log\ N_{e2} + log\ N_{e1}}$
	%}

\end{Algoritmos}