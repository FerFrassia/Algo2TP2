\section{DCNet}

\subsection{Interfaz}

\begin{Interfaz}
  
  %\textbf{parámetros formales}\hangindent=2\parindent\\
  %\parbox{1.7cm}{\textbf{géneros}} \\
  %\parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    %\InterfazFuncion{Verifica?}{\In{c}{conj(tag)}, \In{r}{rest}}{$\alpha$}
    %{$res \igobs a$}
    %[$\Theta(copy(a))$]
    %[función de copia de $\alpha$'s]
  %}

  \textbf{se explica con}: \tadNombre{DCNet, Iterador Unidireccional($\alpha$)}.

  \textbf{géneros}: \TipoVariable{dcnet}.

  \Titulo{Operaciones básicas de DCNet}
	

  \InterfazFuncion{Red}{\In {d}{dcnet}}{red}
  %[ACA VA EL PRE (SI LO HUBIERA)]
  {$res \igobs$ red($d$)}
  [\Complejidad{1}]
  [Devuelve la red del dcnet.]
  
  \InterfazFuncion{CaminoRecorrido}{\In {d}{dcnet}, \In{p}{paquete} }{secu(compu)}
  [$p$ $\in$ paqueteEnTransito?($d,p$)]
  {$res \igobs$ caminoRecorrido($d,p$))}
  [\Complejidad{n*log_2 (k)}]
  [Devuelve una secuencia con las computadoras por las que paso el paquete.]
  
  \InterfazFuncion{cantidadEnviados}{\In {d}{dcnet}, \In {c}{compu}}{nat}
  [$c$ $\in$ computadoras(red($d$))]
  {$res \igobs$ cantidadEnviados($d,c$)}
  [\Complejidad{|$c$.id|}]
  [Devuelve la cantidad de paquetes que fueron enviados desde la computadora.]
  
  \InterfazFuncion{enEspera}{\In {d}{dcnet}, \In {c}{compu}}{itPaquete}
  [$c$ $\in$ computadoras(red($d$))]
  {$res \igobs$ enEspera($d,c$)}
  [\Complejidad{|$c$.id|}]
  [Devuelve los paquetes que se encuentran en ese momento en la computadora.]
  
  \InterfazFuncion{IniciarDCNet}{\In {r}{red}}{dcnet}
  %[ACA VA EL PRE (SI LO HUBIERA)]
  {$res \igobs$ iniciarDCNet($r$)}
  [\Complejidad{N*L}]
  [Inicia un dcnet con la red y sin paquetes.]

  \InterfazFuncion{CrearPaquete}{\In {p}{paquete}, \Inout {d}{dcnet}}{}
  [$d_0 \equiv d$ $\wedge$ $\neg$ (($\exists$ $p_1$: paquete)(paqueteEnTransito($s,p_1$) $\wedge$ id($p_1$) $=$ id($p$)) $\wedge$ origen($p$) $\in$ computadoras(red($d$))$\yluego$ destino($p$) $\in$ computadoras(red($d$))$\yluego$ hayCamino?(red($d$,origen($p$),destino($p$))  ]
  {$res \igobs$ iniciarDCNet($r$)}
  [\Complejidad{L+log_2(k)}]
  [Agrega el paquete al dcnet.]
  
  \InterfazFuncion{AvanzarSegundo}{\Inout {d}{dcnet}}{}
  [$d_0 \equiv d$ ]
  {$d$ $\igobs$ avanzarSegundo($c_0$)}
  [\Complejidad{N*(L+log_2(k)}]
  [El paquete de mayor prioridad de cada computadora avanza a su proxima computadora siendo esta la del camino mas corto.]
  
  
  \InterfazFuncion{PaqueteEnTransito?}{\In {d}{dcnet}, \In {p}{paquete}}{bool}
  [ ]
  {$res$ $\igobs$ paqueteEnTransito?($d$,$p$)}
  [\Complejidad{N*log_2(k)}]
  [Devuelve si el paquete esta o no en alguna computadora del sistema.]
  
  
  \InterfazFuncion{LaQueMasEnvio}{\In {d}{dcnet)}}{compu}
  []
  {$res$ $\igobs$ laQueMasEnvio($d$)}
  [\Complejidad{1}]
  [Devuelve la computadora que mas paquetes envio.]
	
	\Titulo{Operaciones del iterador}
  
\end{Interfaz}

\subsection{Representacion}

\begin{Representacion}

%DESCRIPCION

\bigskip
\begin{Estructura}{dcnet}[e\_dc]
	\begin{Tupla}[e\_dc]
		\tupItem{red}{red}
		\tupTupItem{\\MasEnviante}{\TipoVariable{tupla}$($\ignorespaces
			\emph{compu}: \TipoVariable{compu}, 
			\emph{enviados}: \TipoVariable{nat}$)$}
		\tupTupItem{\\CompYPaq}{\TipoVariable{DiccString}$($\ignorespaces
			\emph{compu}: \TipoVariable{compu},
			\TipoVariable{tupla}$($\ignorespaces
			\emph{MasPriori}:{DiccRapido}$($\ignorespaces
			\emph{prioridad} :{nat},
			\emph{PaqdePriori}:{conj$($paquete$)$}
			 $)$,
			\emph{PaqYCam}:{DiccRapido} $($\ignorespaces
			\emph{paq}:{paquete},
			\emph{CamRecorrido}:{secu$($compu$)$
			}
			}
	
	\end{Tupla}
\end{Estructura}

\subsection{InvRep y Abs}

\begin{enumerate}
 \item{El conjunto de estaciones de 'mapa' es igual al conjunto con todas las claves de 'RURenEst'.}
 \item{La longitud de 'RURs' es mayor o igual a '\#RURHistoricos'.}
 \item{Todos los elementos de 'RURs' cumplen que su primer componente ('id') corresponde con su posicion en 'RURs'. 
       Su Componente 'e' es una de las estaciones de 'mapa', su componente 'esta?' es true si y solo si hay estaciones tales que su 
       valor asignado en 'uniones' es igual a su indice en 'RURs'. Su Componente 'inf' puede ser mayor a cero solamente si hay algun elemento en 
       'sendEv' tal que sea false. Cada elemento de 'sendEv' es igual a verificar 'carac' con la estriccion obtenida al buscar el 
       elemento con la misma posicion en la secuencia de restricciones de 'mapa'.}
 \item{Cada valor contenido en la cola del significado de cada estacion de las claves de 'uniones' pertenecen unicamente a la cola asociada a dicha estacion y a ninguna otra de las colas asociadas a otras estaciones. Y cada uno de estos valores es menor a '\#RURHistoricos' y mayor o igual a cero. Ademas la componente 'e' del elemento de la posicion igual a cada valor de las colas asociadas a cada estacion, es igual a la estacion asociada a la cola a la que pertenece el valor.}

\end{enumerate}


\Rep[e\_cr][c]{
	claves(c.RURenEst) $=$ estaciones(c.mapa) $\wedge$ \hfill1 \newline
	\#RURHistoricos $\leq$ Long(c.RURs) $\yluego$
	($\forall$ i:Nat, t:<id:Nat, esta?:Bool, e:String, \hfill2 \newline
	inf:Nat, carac:Conj(Tag), sendEv: ad(Bool)>) \newline
	(i<\#RURHistoricos $\yluego$ ElemDeSecu(c.RURs, i) = t $\impluego$ (t.e $\in$ estaciones(c.mapa) \hfill3 \newline
	$\wedge$ t.id $=$ i $\wedge$ tam(t.sendEv) $=$ long(Restricciones(c.mapa)) $\wedge$ \newline
	(t.inf > 0 $\Rightarrow$ ($\exists$ j:Nat) (j < tam(t.sendEv) $\yluego$ $\neg$ (t.sendEv[j]))) $\wedge$ \newline
	(t.esta? $\Leftrightarrow$ ($\exists$ e1: String) (e1 $\in$ claves(c.RUREnEst) $\yluego$ estaEnColaP?(obtener(e1, c.RUREnEst), t.id))) \newline
	$\wedge$ ($\forall$ h : Nat) (h < tam(t.sendEv) $\impluego$ \newline
	t.sendEv[h] = verifica?(t.carac, ElemDeSecu(Restricciones(c.mapa), h))))) $\yluego$ \newline
	($\forall$ e1, e2: String)(e1 $\in$ claves(c.RUREnEst) $\wedge$ e2 $\in$ claves(c.RUREnEst) $\wedge$ e1 $\neq$ e2 $\impluego$ \hfill4 \newline
	($\forall$ n:Nat)(estaEnColaP?(obtener(e1, c.RUREnEst), n) $\Rightarrow$ $\neg$ estaEnColaP?(obtener(e2, c.RUREnEst), n) $\wedge$
	n < \#RURHistoricos $\yluego$ ElemDeSecu(c.RURs, n).e $=$ e1))
	}
	
	\vspace{3em}
	
	\tadOperacion{estaEnColaP?}{ColaPri, Nat}{Bool}{}
	\vspace{1em}
	\tadAxioma{estaEnColaP?(cp, n)}{
	\IF vacia?(cp) 
	THEN false 
	ELSE 
	      {\IF desencolar(cp) = n 
	      THEN true 
	      ELSE estaEnColaP?(Eliminar(cp, desencolar(cp)), n) 
	      FI}
	FI}
	
	\vspace{3em}
	
	\Abs[e\_cr]{ciudad}[c]{u}{
		\\ c.\#RURHistoricos = ProximoRUR(U) $\wedge$ c.mapa = mapa(u) $\yluego$
		\\ robots(u) = RURQueEstan(c.RURs) $\yluego$ 
		\\ ($\forall$ n:Nat) (n $\in$ robots(u) $\impluego$ estacion(n,u) = c.RURs[n].e $\wedge$
		\\ tags(n,u) = c.RURs[n].carac $\wedge$ \#infracciones(n,u) = c.RURs[n].inf)}
		
	\vspace{3em}
	\tadOperacion{RURQueEstan}{secu(tupla)}{Conj(RUR)}{}
	\vspace{1em}
	tupla es <id:Nat, esta?:Bool, inf:Nat, carac:Conj(tag), sendEv:arreglo dimensionable(bool)>
	\vspace{1em}
	\tadAxioma{RURQueEstan(s)}{
	\IF vacia?(s)
	THEN $\emptyset$
	ELSE 
	      {\IF $\Pi_2$(prim(fin(s)))
	      THEN {$\Pi_1$(prim(fin(s)))} $\cup$ RURQueEstan(fin(s))
	      ELSE RURQueEstan(fin(s))
	      FI}
	FI}
	
\vspace{3em}

\begin{Estructura}{it}[e\_it]
	\begin{Tupla}[e\_it]
		\tupItem{i}{nat}
		\tupItem{maxI}{nat}
		\tupItem{ciudad}{puntero(ciudad)}
	\end{Tupla}
\end{Estructura}

\Rep[e\_it][it]{
	it.i $\leq$ it.maxI $\wedge$ maxI $=$ ciudad.\#RURHistoricos
}

\Abs[e\_it]{itUni($\alpha$)}[u]{it}{
	(HayMas?(u) $\yluego$ Actual(u) = ciudad.RURs[it.i] $\wedge$ Siguientes(u, $\emptyset$) = VSiguientes(ciudad, it.i++, $\emptyset$) $\vee$ ($\neg$HayMas?(u))
}

\vspace{2em}
	
\tadOperacion{Siguientes}{itUni u, conj(RURs) cr}{conj(RURs)}{}
														
\vspace{1em}

\tadAxioma{Siguientes(u, cr)}{\IF HayMas(u)? THEN Ag(Actual(Avanzar(u)), Siguientes(Avanzar(u), cr)) ELSE Ag($\emptyset$, cr) FI}
		
\vspace{1em}

\tadOperacion{VSiguientes}{ciudad c, Nat i, conj(RURs) cr}{conj(RURs)}{}
														
\vspace{1em}

\tadAxioma{VSiguientes(u, i, cr)}{\IF i < c.\#RURHistoricos THEN Ag(c.RURs[i], VSiguientes(u, i++, cr))) ELSE Ag($\emptyset$, cr) FI}

\vspace{2em}

\end{Representacion}

%tupla<mapa:mapa, robEnEst: dicctrie(estacion, conj(puntero(RUR))), robots: conj(RUR)>

\subsection{Algoritmos}

\begin{Algoritmos}




	\begin{Algoritmo}{iRed}{\In {d}{dcnet}}{red}
	{
		\State $res$ $\gets$ ($d$.red) \ComplejidadDer{1}
	}
	{\Complejidad{1}}
	{}
	
	\end{Algoritmo}
	
	
	
	
	\begin{Algoritmo}{iCaminoRecorrido}{\In {d}{dcnet},\In {p}{paquete}}{secu(compu)}
	{
		\State var $it$ $\gets$ \NombreFuncion {computadoras}(d.red) \ComplejidadDer{1}
		\State var $esta$: bool $\gets$ false
		\While {\NombreFuncion {HaySiguiente}($it$) $\wedge$ $\neg$ esta}   \ComplejidadDer{n}
			\State var:diccRapido $diccpaq$ $\gets$  \NombreFuncion {obtener}(\NombreFuncion{Siguiente}($it$).id, $d$.CompYPaq).PaqYCam)	\ComplejidadDer{L}
			\If {\NombreFuncion {def?}($p$,$diccpaq$)}	\ComplejidadDer{L+ log_2(N)}
				\State $esta$ $\gets$ true \ComplejidadDer{1}
				\State $res$ $\gets$ \NombreFuncion {obtener}($p$, $diccpaq$).CamRecorrido	\ComplejidadDer{L + log_2(N)+ 1} 		
			\EndIf
			\State \NombreFuncion {Avanzar}($it$)  \ComplejidadDer{1}
		\EndWhile
	}
	{\Complejidad{ }}
	{}
	\end{Algoritmo}
	
	
	
	
	
	\begin{Algoritmo}{iCantidadEnviados}{\In {d}{dcnet}, \In {c}{compu}}{nat}
	{
		\State $res$ $\gets$ \NombreFuncion {obtener}($c$.id,$d$.CompYPaq).Enviados  \ComplejidadDer{L}
	}
	{\Complejidad{L}}
	{Siendo L la longitud de el ID de $c$}
	\end{Algoritmo}
	
	
	
	
	\begin{Algoritmo}{iEnEspera}{\In {d}{dcnet}, \In {c}{compu}}{itPaquete)}
	{
		\State $res$  $\gets$ \NombreFuncion {claves}(\NombreFuncion {obtener}($c$.id, $d$.CompYPaq).PaqYCam) \ComplejidadDer{L}
	}
	{\Complejidad{|L|}}
	{Siendo L la longitud  del ID de $c$}
	\end{Algoritmo}
	
	
	
	
	
	
	\begin{Algoritmo}{iIniciarDCNet}{\In {r}{red}, \Inout {d}{dcnet}}{}
	{
		\State $d$.red $\gets$ r \ComplejidadDer{NOSE}
		\State  var $it$ $\gets$ \NombreFuncion {computadoras}(red) \ComplejidadDer{1}
		\State $d$.MasEnviante $\gets$ tupla(\NombreFuncion {Siguiente}($it$),0) \ComplejidadDer{1}
		\State $d$.CompyPaq $\gets$ Vacio() \ComplejidadDer{1}
		\While {\NombreFuncion{HaySiguiente}($it$)}  \ComplejidadDer{N}
			\State \NombreFuncion {Definir}(\NombreFuncion {Siguiente}($it$).id, tupla(\NombreFuncion {Vacio}(),\NombreFuncion {Vacio}(), 0), $d$.CompyPaq) \ComplejidadDer{L + 1 + 1}
			\State \NombreFuncion {Avanzar}($it$) \ComplejidadDer{1}
		\EndWhile
		
	}
	{\Complejidad{N*L}}
	{Siendo N la cantidad de computadoras en la red y L el ID mas largo de ellas.}
	\end{Algoritmo}
	
	
	
	
	
	
	\begin{Algoritmo}{iCrearPaquete}{\In {p}{paquete}, \Inout {d}{dcnet}}{}
	{
	
		\State var $diccprio$: diccRapido $\gets$ \NombreFuncion {obtener}($p$.origen, $d$.CompYPaq).MasPriori)	\ComplejidadDer{L}
		\State var $dicccam$: diccRapido $\gets$ \NombreFuncion {obtener}($p$.origen, $d$.CompYPaq).PaqYCam) \ComplejidadDer{L}
		\If {$\neg$ \NombreFuncion {def?}(p.prioridad, $diccprio$)}	\ComplejidadDer{log_2(s)}
			\State \NombreFuncion {Definir}($p$.prioridad,\NombreFuncion {Agregar}(\NombreFuncion {Vacio}(), $p$), $diccprio$)	\ComplejidadDer{log_2(s)}
		\Else 
			\State \NombreFuncion {Definir}($p$.prioridad,\NombreFuncion{Agregar}(\NombreFuncion {obtener}($p$.prioridad, $diccprio$), $p$), $diccprio$	\ComplejidadDer{log_2(s)}
		\EndIf
		
		\State \NombreFuncion{definir}($p$, $dicccam$, \NombreFuncion {AgregarAtras}(<>,p.origen)	\ComplejidadDer{log_2(k)}
		
		
		}
	{\Complejidad{L+ log_2(k)}}
	{}
	\end{Algoritmo}
	
	
	
	\begin{Algoritmo}{iAvanzarSegundo}{\Inout {d}{dcnet}}{}
	{
		\State var $it$ $\gets$ \NombreFuncion {computadoras}(red) \ComplejidadDer{1}
		\State var aux $\gets$ \NombreFuncion {Vacia}()	\ComplejidadDer{1}
		\While {\NombreFuncion {HaySiguiente}($it$)}	\ComplejidadDer{N}
		
			\State var $diccprio$: diccRapido $\gets$ \NombreFuncion {obtener}( \NombreFuncion{Siguiente}($it$).id, $d$.CompYPaq).MasPriori)	\ComplejidadDer{L}
		\State var $dicccam$: diccRapido $\gets$ \NombreFuncion {obtener}(\NombreFuncion{Siguiente}($it$).id, $d$.CompYPaq).PaqYCam) \ComplejidadDer{L}
			\If {$\neg$ \NombreFuncion {Vacio?}($diccprio$)} \ComplejidadDer{1}
				\State var $paq$: paquete $\gets$ \NombreFuncion{Primero}(\NombreFuncion {obtener}(\NombreFuncion {DameMax}($diccprio$), $diccprio$)) \ComplejidadDer{log_2(k)+1+1}
				\State \NombreFuncion {AgregarAdelante}(aux, tupla(paq: $paq$,pcant: $it$.id, camrecorrido: \NombreFuncion{obtener}($paq$, $dicccam$)) \ComplejidadDer{1+ log_2(k)}
			
				\State \NombreFuncion {Eliminar}(\NombreFuncion{obtener}(\NombreFuncion {DameMax}($diccprio$), $diccprio$), $paq$) \ComplejidadDer{log_2(k)+log_2(k)+1}%elimino el primero entonces es o 1( porque paq era el primero)
				\If {\NombreFuncion{EsVacio?}(\NombreFuncion{obtener}(\NombreFuncion {DameMax}($diccprio$), $diccprio$)} \ComplejidadDer{log_2(k)}
					\State \NombreFuncion{borrar}(\NombreFuncion {DameMax}($diccprio$), $diccprio$) \ComplejidadDer{log_2(k)}
				\EndIf
				\State \NombreFuncion{borrar}($paq$, $dicccam$) \ComplejidadDer{log_2(k)}
				
				
				\State	\NombreFuncion {obtener}(\NombreFuncion{Siguiente}($it$).id, $d$.CompYPaq).Enviados ++ \ComplejidadDer{L}
					\If {\NombreFuncion {obtener}(\NombreFuncion{Siguiente}($it$).id, $d$.CompYPaq).Enviados > ($d$.MasEnviante).enviados }	\ComplejidadDer{L+1}
						\State $d$.MasEnviante $\gets$ tupla(\NombreFuncion{Siguiente}($it$), \NombreFuncion {obtener}(\NombreFuncion{Siguiente}($it$).id, $d$.CompYPaq).Enviados )	\ComplejidadDer{L+1}
					\EndIf
							
				\EndIf
				
				\State \NombreFuncion{Avanzar}($it$) \ComplejidadDer{1}
		\EndWhile
		
		\State var $itaux$ $\gets$ \NombreFuncion{crearIt}(aux) \ComplejidadDer{1}
		\While {\NombreFuncion{HaySiguiente}($itaux$)} \ComplejidadDer{Nk}
		
			\State var $proxpc$: compu $\gets$ \NombreFuncion{Primero}(\NombreFuncion{Siguiente}(\NombreFuncion{CaminosMinimos}($d$.red, $itaux$.pcant, $itaux$.destino)) \ComplejidadDer{L_1 + L_2}
			
			\State var $diccprio$: diccRapido $\gets$ \NombreFuncion {obtener}( $proxpc$.id, $d$.CompYPaq).MasPriori)	\ComplejidadDer{L}
		\State var $dicccam$: diccRapido $\gets$ \NombreFuncion {obtener}($proxpc$.id, $d$.CompYPaq).PaqYCam) \ComplejidadDer{L}
			
			
			\If {\NombreFuncion{def?}(($itaux$.paq).prioridad, $diccprio$)}	\ComplejidadDer{log_2(k)}
			
			\State 	var $mismaprio$: conj(paquetes) $\gets$ \NombreFuncion{Agregar}(\NombreFuncion {obtener}($it3$.paq.prioridad, $diccprio$), $it3$.paq)	\ComplejidadDer{log_2(k)}
			\State {\NombreFuncion{definir}(($it3$.paq).prioridad, $mismaprio$, $diccprio$)} \ComplejidadDer{log_2(k)}
		
		
		 	\Else 
		 		\State \NombreFuncion{Definir}($it3$.prioridad, \NombreFuncion{Agregar}(\NombreFuncion{Vacio}(),$it3$.paq), $diccprio$)\ComplejidadDer{log_2(k)}
			\EndIf
		
			\State \NombreFuncion{definir}($p$.paq,\NombreFuncion{AgregarAtras}($it3$.camrecorrido ,$proxpc$), $dicccam$)	\ComplejidadDer{log_2(k)}
			\State \NombreFuncion{EliminarSiguiente}($it3$) \ComplejidadDer{1}
			\State \NombreFuncion{Avanzar}($it3$) \ComplejidadDer{1}
		\EndWhile
		
		}
	{\Complejidad{N*(L+log_2(k)}}
	{}
	\end{Algoritmo}
	
	
	\begin{Algoritmo}{iPaqueteEnTransito?}{\In {d}{dcnet}, \In {p}{paquete}}{bool}
	{
		\State var $it$  $\gets$ \NombreFuncion {crearIt}(\NombreFuncion {computadoras}(d.red) \ComplejidadDer{1}
		\State var $esta$: bool $\gets$ false \ComplejidadDer{1}
		\While{\NombreFuncion{HaySiguiente}($it$) $\wedge$ $\neg$ $esta$ }\ComplejidadDer{}
			\State $esta$ $\gets$ \NombreFuncion{def?}(\NombreFuncion{obtener}(d.CompYPaq,$i$.id).PaqYCam , $p$) \ComplejidadDer{log_2(k)}
			\State \NombreFuncion{Avanzar}($it$)\ComplejidadDer{1}
		\EndWhile
			\State $res$ $\gets$ $esta$	\ComplejidadDer{1}
	
	
	}
	{\Complejidad{N*log(k)}}
	{}
	\end{Algoritmo}
	
	
	
	\begin{Algoritmo}{iLaQueMasEnvio}{\In {d}{dcnet}}{compu}
	{
		\State $res$  $\gets$ ($d$.MasEnviante).compu \ComplejidadDer{1}
	}
	{\Complejidad{1}}
	{}
	\end{Algoritmo}
	
	
	
	
	

	%\Algoritmo{IENTRAR}{\In {ts}{conj(tags)}, \In {e}{estación}, \Inout {c}{ciudad}}{}{
		%\State e\_ciudad.cRUR $\gets$ e\_ciudad.cRUR + 1 \ComplejidadDer{1}
		%\State var sendas $\gets$ EVALUARSENDAS(ts, e\_ciudad.m) \ComplejidadDer{S \cdot R}
		%\State var nRUR $\gets$ tupla(e\_ciudad.RURs, e, 0, ts, sendas) \ComplejidadDer{1}
		%\State AGREGARATRAS(e\_ciudad.RURs, nRUR) \ComplejidadDer{1}
		%\State obtEst = \&(SIGNIFICADO(e.RUREnEst, e)) \ComplejidadDer{|e|}
		%\State ENCOLAR(obtEst, tupla(e\_ciudad.cRUR, 0)) \ComplejidadDer{log\ N}
	%}{\Complejidad{|e| + S \cdot R + log\ N}}{
	%Justificacion.
	%}
	%
	%\newpage
	%
	%\Algoritmo{IMOVER}{\In {u}{nat}, \In {e2}{estación}, \Inout {c}{ciudad}}{}{
		%\State var est $\gets$ OBTENERCOLAEST(c.RUREnEst, c.RURs[u].e) \ComplejidadDer{|e1|}
		%\State SACARRUR(est, u) \ComplejidadDer{log\ N_{e1}}
		%\State INFRACCIONO?(u, NROCONEXION(c.RURs[u].e, e2) \ComplejidadDer{|e1| + |e2|}
		%\State MODIFICARRUR(u) \ComplejidadDer{1}
		%\State est $\gets$ OBTENERCOLAEST(c.RUREnEst, e2) \ComplejidadDer{|e2|}
		%\State METERRUR(est, u) \ComplejidadDer{log\ N_{e2}}
	%}{\Complejidad{|e1| + |e2| + log\ N_{e1} + log\ N_{e2}}}{
		%$\Complejidad{|e1|} + \Complejidad{|e2|} + \Complejidad{log\ N_{e1}} + 
		%\Complejidad{log\ N_{e2}} + \Complejidad{|e1| + |e2|} + \Complejidad{1} =$\\
		%$2 * \Complejidad{|e1| + |e2|} + \Complejidad{log\ N_{e2} + log\ N_{e1}} =$\\
		%$\Complejidad{|e1| + |e2|} + \Complejidad{log\ N_{e2} + log\ N_{e1}} =$\\
		%$\Complejidad{|e1| + |e2| + log\ N_{e2} + log\ N_{e1}}$
	%}

\end{Algoritmos}