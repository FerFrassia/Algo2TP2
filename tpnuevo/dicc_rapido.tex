\section{DiccRapido}

\begin{Interfaz}
  
  \textbf{se explica con}: \tadNombre{Diccionario(clave, significado)}.

  \textbf{géneros}: \TipoVariable{diccRapido}.

  \Titulo{Operaciones básicas de DICCRAPIDO}

  \InterfazFuncion{Def?}{\In{c}{clave}, \In{d}{diccRapido}}{bool}
  [true]
  {$res$ $\igobs$ def?($c, d$)}
  [\Complejidad{log_2\ n}, siendo n la cantidad de claves]
  [Verifica si una clave está definida.]
  
 \InterfazFuncion{Obtener}{\In{c}{clave}, \In{d}{diccRapido}}{significado}
 [def?($c, d$)]
 {$res$ $\igobs$ obtener($c, d$)}
 [$\Complejidad{log_2\ n}$, siendo n la cantidad de claves]
 [Devuelve el significado asociado a una clave]
  
 \InterfazFuncion{Vacío}{}{diccRapido}
 [true]
 {$res$ $\igobs$ vacío()}
 [$\Complejidad{1}$]
 [Crea un nuevo diccionario vacío]  
  
 \InterfazFuncion{Definir}{\In{c}{clave}, \In{s}{significado}, \Inout{d}{diccRapido}}{}
 [$d$ $\igobs$ $d_0$]
 {$d$ $\igobs$ definir($c, s, d_0$)}
 [$\Complejidad{log_2\ n}$, siendo n la cantidad de claves]
 [Define la clave, asociando su significado, al diccionario]
  
 \InterfazFuncion{Borrar}{\In{c}{clave}, \Inout{d}{diccRapido}}{}
 [$d$ $\igobs$ $d_0$ $\wedge$ def?($c, d_0$)]
 {$d$ $\igobs$ borrar($c, d_0$)}
 [$\Complejidad{log_2\ n}$, siendo n la cantidad de claves]
 [Borra la clave del diccionario]
 
 \InterfazFuncion{Claves}{\In{d}{diccRapido}}{itPaquete}
 [true]
 {$res$ $\igobs$ claves($d$)}
 [$\Complejidad{1}$]
 [Devuelve un iterador de paquete]  
  
\end{Interfaz}

\subsection{Representacion}

\begin{Representacion}

Para representar el diccionario, elegimos hacerlo sobre AVL. Sabiendo que la cantidad de claves no está acotada, este AVL estará representado con nodos y punteros. Cabe destacar, que las claves del diccionario deben contener una relación de orden. Las claves y los significados se pasan por referencia.

\begin{Estructura}{diccRapido}[estr]
	\begin{Tupla}[estr]
		\tupTupItem{raiz}{\TipoVariable{puntero}(nodo)}
		\tupItem{tam}{nat}
		%\tupItem{cVac}{bool}
	\end{Tupla}
	
	\begin{Tupla}[nodo]
		\tupItem{clave}{clave}
		\tupItem{significado}{significado}
		\tupTupItem{padre}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{izq}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{der}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{alt}{\TipoVariable{nat}}
	\end{Tupla}
	
\end{Estructura}

\subsection{InvRep y Abs}

\end{Representacion}

\subsection{Algoritmos}

\begin{Algoritmos}

\Algoritmo{IDef?}{\In{c}{clave}, \In{d}{diccRapido}}{bool}{
	\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
	\While{*(pNodo) != NULL} \ComplejidadDer{log_2\ n}
		\If{*(pNodo).clave == c} \ComplejidadDer{1}
			\State $res$ $\gets$ true \ComplejidadDer{1}
			\State return $res$ \ComplejidadDer{1}
		\Else
			\If{c $\textgreater$ *(pNodo).clave} \ComplejidadDer{1}
				\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
			\Else
				\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
			\EndIf	
		\EndIf		
	\EndWhile
	\State $res$ $\gets$ false \ComplejidadDer{1}
	}{\Complejidad{log_2\ n}}{
}

\Algoritmo{IObtener}{\In{c}{clave}, \In{d}{diccRapido}}{significado}{
	\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
	\While{*(pNodo).clave != c} \ComplejidadDer{log_2\ n}
		\If{c $\textgreater$ *(pNodo).clave} \ComplejidadDer{1}
			\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
		\Else
			\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
		\EndIf			
	\EndWhile
	\State $res$ $\gets$ *(pNodo).significado \ComplejidadDer{1}
	}{\Complejidad{log_2\ n}}{
}
	
\Algoritmo{IVacío}{}{diccRapido}{
	\State var $res$: diccRapido $\gets$ tupla(NULL, 0) \ComplejidadDer{1}
}{\Complejidad{1}}{
}	

\Algoritmo{IDefinir}{\In{c}{clave}, \In{s}{significado}, \Inout{d}{diccRapido}}{}{
	\State \If{d.raiz == NULL} \ComplejidadDer{1}
			\State d.raiz $\gets$ $\&$tupla(c, s, NULL, NULL, NULL, 1) \ComplejidadDer{1}
		  	\State d.tam $\gets$ 1 \ComplejidadDer{1}
		  \Else
		  	\If{Def?(c, d)} \ComplejidadDer{log_2\ n}
				\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
				\While{*(pNodo).clave != c} \ComplejidadDer{log_2\ n}
					\If{c $\textgreater$ *(pNodo).clave} \ComplejidadDer{1}
						\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
					\Else
						\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
					\EndIf			
				\EndWhile
				\State *(pNodo).significado $\gets$ s \ComplejidadDer{1}
			\Else
		  		\State var	seguir: bool $\gets$ true \ComplejidadDer{1}
				\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
				\State var camino: arreglo[$\lfloor log_2\ (d.tam) \rfloor+ 1$] de puntero(nodo) \ComplejidadDer{\lfloor log_2\ (d.tam) \rfloor+ 1}
 				\State var nroCamino: nat $\gets$ 0 \ComplejidadDer{1}
				\State camino[0] $\gets$ pNodo \ComplejidadDer{1}
				\While{seguir == true}
					\If{c $\textgreater$ *(pNodo).clave $\wedge$ *(pNodo).der == NULL} \ComplejidadDer{1}
							\If{*(pNodo).izq == NULL}
								\State *(pNodo).alt $\gets$ 2 \ComplejidadDer{1}
							\Else
							\EndIf
						 	\State *(pNodo).der $\gets$ $\&$tupla(c, s, pNodo, NULL, NULL, 1) \ComplejidadDer{1}
							\State nroCamino $\gets$ nroCamino + 1 \ComplejidadDer{1}
							\State camino[nroCamino] $\gets$ *(pNodo).der \ComplejidadDer{1}
							\State seguir $\gets$ false \ComplejidadDer{1}
							
				        \Else
					  		\If{c $\textgreater$ *(pNodo).clave $\wedge$ *(pNodo).der != NULL} \ComplejidadDer{1}
								\If{*(pNodo).izq == NULL} \ComplejidadDer{1}
									\State *(pNodo).alt $\gets$ *(pNodo).alt + 1 \ComplejidadDer{1}
								\Else
									\State *(pNodo).alt $\gets$ max(*(*(pNodo).izq).alt, *(*(pNodo).der).alt + 1) \Complejidad{1}
								\EndIf
								
								\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
								\State nroCamino $\gets$ nroCamino + 1 \ComplejidadDer{1}
								\State camino[nroCamino] $\gets$ *(pNodo).der \ComplejidadDer{1}			
							\Else
							\EndIf	
				        \EndIf
				\EndWhile
			\EndIf			
		  \EndIf
			
			 
}{\Complejidad{log_2\ n}}{
}

\Algoritmo{IRotarSimpleIzq}{}{}{
	\State 
}{\Complejidad{1}}{
}	

\Algoritmo{IRotarSimpleDer}{}{}{
	\State 
}{\Complejidad{1}}{
}	

\Algoritmo{IRotarDobleIzq}{}{}{
	\State 
}{\Complejidad{1}}{
}	

\Algoritmo{IRotarDobleDer}{}{}{
	\State 
}{\Complejidad{1}}{
}	




\end{Algoritmos}




