\section{DiccRapido}

\begin{Interfaz}
  
  \textbf{se explica con}: \tadNombre{Diccionario(clave, significado)}.

  \textbf{géneros}: \TipoVariable{diccRapido}.

  \Titulo{Operaciones básicas de DICCRAPIDO}

  \InterfazFuncion{Def?}{\In{c}{clave}, \In{d}{diccRapido}}{bool}
  [true]
  {$res$ $\igobs$ def?($c, d$)}
  [\Complejidad{log_2\ n}, siendo n la cantidad de claves]
  [Verifica si una clave está definida.]
  
 \InterfazFuncion{Obtener}{\In{c}{clave}, \In{d}{diccRapido}}{significado}
 [def?($c, d$)]
 {$res$ $\igobs$ obtener($c, d$)}
 [$\Complejidad{log_2\ n}$, siendo n la cantidad de claves]
 [Devuelve el significado asociado a una clave]
  
 \InterfazFuncion{Vacío}{}{diccRapido}
 [true]
 {$res$ $\igobs$ vacío()}
 [$\Complejidad{1}$]
 [Crea un nuevo diccionario vacío]  
  
 \InterfazFuncion{Definir}{\In{c}{clave}, \In{s}{significado}, \Inout{d}{diccRapido}}{}
 [$d$ $\igobs$ $d_0$]
 {$d$ $\igobs$ definir($c, s, d_0$)}
 [$\Complejidad{log_2\ n}$, siendo n la cantidad de claves]
 [Define la clave, asociando su significado, al diccionario]
  
 \InterfazFuncion{Borrar}{\In{c}{clave}, \Inout{d}{diccRapido}}{}
 [$d$ $\igobs$ $d_0$ $\wedge$ def?($c, d_0$)]
 {$d$ $\igobs$ borrar($c, d_0$)}
 [$\Complejidad{log_2\ n}$, siendo n la cantidad de claves]
 [Borra la clave del diccionario]
 
 \InterfazFuncion{Claves}{\In{d}{diccRapido}}{itPaquete}
 [true]
 {$res$ $\igobs$ claves($d$)}
 [$\Complejidad{1}$]
 [Devuelve un iterador de paquete]  
  
 \InterfazFuncion{Vacío?}{\In{d}{diccRapido}}{bool}
 [true]
 {$res$ $\igobs$ vacío?($d$)}
 [$\Complejidad{1}$]
 [Verifica si el diccionario vacío]
 
 \InterfazFuncion{DameMax}{\In{d}{diccRapido}}{clave}
 [$\neg$vacío?(d)]
 {$res$ $\igobs$ dameMax($d$)}
 [$\Complejidad{log_2\ n}$]
 [Devuelve la mayor clave]
 
 \Titulo{Operaciones del Iterador}
 
 \InterfazFuncion{CrearIt}{\In{d}{diccRapido}}{itClaves}
 [true]
 {$res$ $\igobs$ crearItUni(secuClaves(d))}
 [$\Complejidad{1}$]
 [Crea el iterador de claves]
 
 \InterfazFuncion{HayMas?}{\In{it}{itClaves}}{bool}
 [true]
 {$res$ $\igobs$ HayMas?($it$)}
 [$\Complejidad{1}$]
 [Verifica si hay más elementos a iterar]
 
 \InterfazFuncion{Actual}{\In{it}{itClaves}}{clave}
 [HayMas?($it$)]
 {$res$ Actual($it$)}
 [$\Complejidad{1}$]
 [Devuelve el actual del iterador]
 
 \InterfazFuncion{Avanzar}{\Inout{it}{itClaves}}{}
 [$it$ $\igobs$ $it_0$ $\wedge$ HayMas?($it_0$)]
 {$it$ $\igobs$ Avanzar($it_0$)} 
 [$\Complejidad{NO SE}$]
 [Avanza el iterador]
  
\end{Interfaz}

\subsection{Representacion}

\begin{Representacion}

Para representar el diccionario, elegimos hacerlo sobre AVL. Sabiendo que la cantidad de claves no está acotada, este AVL estará representado con nodos y punteros. Cabe destacar, que las claves del diccionario deben contener una relación de orden. Las claves y los significados se pasan por referencia.

\begin{Estructura}{diccRapido}[estr]
	\begin{Tupla}[estr]
		\tupTupItem{raiz}{\TipoVariable{puntero}(nodo)}
		\tupItem{tam}{nat}
		%\tupItem{cVac}{bool}
	\end{Tupla}
	
	\begin{Tupla}[nodo]
		\tupItem{clave}{clave}
		\tupItem{significado}{significado}
		\tupTupItem{padre}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{izq}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{der}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{alt}{\TipoVariable{nat}}
	\end{Tupla}
	
\end{Estructura}

\subsection{InvRep y Abs}

\end{Representacion}

\subsection{Algoritmos}

\begin{Algoritmos}

\Algoritmo{IDef?}{\In{c}{clave}, \In{d}{diccRapido}}{bool}{
	\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
	\While{*(pNodo) != NULL} \ComplejidadDer{log_2\ n}
		\If{*(pNodo).clave == c} \ComplejidadDer{1}
			\State $res$ $\gets$ true \ComplejidadDer{1}
			\State return $res$ \ComplejidadDer{1}
		\Else
			\If{c $\textgreater$ *(pNodo).clave} \ComplejidadDer{1}
				\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
			\Else
				\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
			\EndIf	
		\EndIf		
	\EndWhile
	\State $res$ $\gets$ false \ComplejidadDer{1}
	}{\Complejidad{log_2\ n}}{
}

\Algoritmo{IObtener}{\In{c}{clave}, \In{d}{diccRapido}}{significado}{
	\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
	\While{*(pNodo).clave != c} \ComplejidadDer{log_2\ n}
		\If{c $\textgreater$ *(pNodo).clave} \ComplejidadDer{1}
			\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
		\Else
			\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
		\EndIf			
	\EndWhile
	\State $res$ $\gets$ *(pNodo).significado \ComplejidadDer{1}
	}{\Complejidad{log_2\ n}}{
}
	
\Algoritmo{IVacío}{}{diccRapido}{
	\State var $res$: diccRapido $\gets$ tupla(NULL, 0) \ComplejidadDer{1}
}{\Complejidad{1}}{
}	

\Algoritmo{IDefinir}{\In{c}{clave}, \In{s}{significado}, \Inout{d}{diccRapido}}{}{
	\State \If{d.raiz == NULL} \ComplejidadDer{1}
			\State d.raiz $\gets$ $\&$tupla(c, s, NULL, NULL, NULL, 1) \ComplejidadDer{1}
		  	\State d.tam $\gets$ 1 \ComplejidadDer{1}
		  \Else
		  	\If{\NombreFuncion{Def?}(c, d)} \ComplejidadDer{log_2\ n}
				\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
				\While{*(pNodo).clave != c} \ComplejidadDer{log_2\ n}
					\If{c $\textgreater$ *(pNodo).clave} \ComplejidadDer{1}
						\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
					\Else
						\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
					\EndIf			
				\EndWhile
				\State *(pNodo).significado $\gets$ s \ComplejidadDer{1}
			\Else
		  		\State var	seguir: bool $\gets$ true \ComplejidadDer{1}
				\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
				\State var camino: arreglo[$\lfloor log_2\ (d.tam) \rfloor+ 1$] de puntero(nodo) \ComplejidadDer{\lfloor log_2\ (d.tam) \rfloor+ 1}
 				\State var nroCamino: nat $\gets$ 0 \ComplejidadDer{1}
				\State camino[nroCamino] $\gets$ pNodo \ComplejidadDer{1}
				\While{seguir == true} \ComplejidadDer{log2\ n}
					\If{c $\textgreater$ *(pNodo).clave $\wedge$ *(pNodo).der == NULL} \ComplejidadDer{1}
							\If{*(pNodo).izq == NULL} \ComplejidadDer{1}
								\State *(pNodo).alt $\gets$ 2 \ComplejidadDer{1}
							\Else
							\EndIf
						 	\State *(pNodo).der $\gets$ $\&$tupla(c, s, pNodo, NULL, NULL, 1) \ComplejidadDer{1}
							\State nroCamino $\gets$ nroCamino + 1 \ComplejidadDer{1}
							\State camino[nroCamino] $\gets$ *(pNodo).der \ComplejidadDer{1}
							\State seguir $\gets$ false \ComplejidadDer{1}
							
				        \Else
					  		\If{c $\textgreater$ *(pNodo).clave $\wedge$ *(pNodo).der != NULL} \ComplejidadDer{1}
								\If{*(pNodo).izq == NULL} \ComplejidadDer{1}
									\State *(pNodo).alt $\gets$ *(pNodo).alt + 1 \ComplejidadDer{1}
								\Else
									\State *(pNodo).alt $\gets$ max(*(*(pNodo).izq).alt, *(*(pNodo).der).alt + 1) \ComplejidadDer{1}
								\EndIf
								\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
								\State nroCamino $\gets$ nroCamino + 1 \ComplejidadDer{1}
								\State camino[nroCamino] $\gets$ pNodo \ComplejidadDer{1}			
							\Else
								\If{c $\textless$ *(pNodo).clave $\wedge$ *(pNodo).izq == NULL} \ComplejidadDer{1}
									\If{*(pNodo).der ==NULL} \ComplejidadDer{1}
										\State *(pNodo).alt $\gets$ 2 \ComplejidadDer{1}
									\Else
									\EndIf
									\State *(pNodo).izq $\gets$ $\&$tupla(c, s, pNodo, NULL, NULL, 1) \ComplejidadDer{1}
									\State nroCamino $\gets$ nroCamino + 1 \ComplejidadDer{1}
									\State camino[nroCamino] $\gets$ *(pNodo).izq \ComplejidadDer{1}
									\State seguir $\gets$ false \ComplejidadDer{1}
 								\Else
									\If{*(pNodo).der == NULL} \ComplejidadDer{1}
										\State *(pNodo).alt $\gets$ *(pNodo).alt + 1 \ComplejidadDer{1}
									\Else
										\State *(pNodo).alt $\gets$ max(*(*(pNodo).izq).alt + 1, *(*(pNodo).der).alt) \ComplejidadDer{1}
									\EndIf
									\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
									\State nroCamino $\gets$ nroCamino + 1 \ComplejidadDer{1}
									\State camino[nroCamino] $\gets$ pNodo \ComplejidadDer{1}
								\EndIf
							\EndIf	
				        \EndIf
				\EndWhile
				\State d.tam $\gets$ d.tam + 1 \ComplejidadDer{1}
				\While{nroCamino $\geq$ 0} \ComplejidadDer{log2\ n}
					\State pNodo $\gets$ camino[nroCamino] \ComplejidadDer{1}
					\If{|\NombreFuncion{FactorDesbalance}(pNodo)| $>$ 1} \ComplejidadDer{1}
						\State \NombreFuncion{Rotar}(pNodo) \ComplejidadDer{1}
					\Else
					\EndIf
					\State nroCamino $\gets$ nroCamino - 1 \ComplejidadDer{1}
 				\EndWhile
			\EndIf			
		  \EndIf
			
			 
}{\Complejidad{log_2\ n}}{
}

\Algoritmo{IBorrar}{\In{c}{clave}, \Inout{d}{diccRapido}}{}{
	\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
	\State var camino: arreglo[$\lfloor log_2\ (d.tam) \rfloor+ 1$] de puntero(nodo) \ComplejidadDer{\lfloor log_2\ (d.tam) \rfloor+ 1}
 	\State var nroCamino: nat $\gets$ 0 \ComplejidadDer{1}
	\State camino[nroCamino] $\gets$ pNodo \ComplejidadDer{1}	
	\While{c != *(pNodo).clave} \ComplejidadDer{log_2\ n}
		\If{c $\textgreater$ *(pNodo).clave} \ComplejidadDer{1}
			\If{*(pNodo).izq == NULL} \ComplejidadDer{1}
				\State *(pNodo).alt $\gets$ *(pNodo).alt - 1 \ComplejidadDer{1}
			\Else
				\State *(pNodo).alt $\gets$ max(*(*(pNodo).izq).alt, *(*(pNodo).der).alt - 1) \ComplejidadDer{1}
			\EndIf
			\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
			\State nroCamino $\gets$ nroCamino + 1 \ComplejidadDer{1}
			\State camino[nroCamino] $\gets$ pNodo \ComplejidadDer{1}	
		\Else
			\If{*(pNodo).der == NULL} \ComplejidadDer{1}
				\State *(pNodo).alt $\gets$ *(pNodo).alt - 1 \ComplejidadDer{1}
			\Else
				\State *(pNodo).alt $\gets$ max(*(*(pNodo).izq).alt - 1, *(*(pNodo).der).alt) \ComplejidadDer{1}
			\EndIf
			\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
			\State nroCamino $\gets$ nroCamino + 1 \ComplejidadDer{1}
			\State camino[nroCamino] $\gets$ pNodo \ComplejidadDer{1}
		\EndIf			
	\EndWhile
	\If{*(pNodo).izq == NULL $\wedge$ *(pNodo).der == NULL} \ComplejidadDer{1}
		%EL NODO NO TIENE HOJAS
		\If{*(pNodo).padre == NULL} \ComplejidadDer{1}
			\State d.raiz $\gets$ NULL \ComplejidadDer{1}
			\State delete pNodo \ComplejidadDer{1}
		\Else
			\If{*(pNodo).clave == *(*(*(pNodo).padre).izq).clave} \ComplejidadDer{1}
				\State *(*(pNodo).padre).izq $\gets$ NULL \ComplejidadDer{1}
			\Else
				\State *(*(pNodo).padre).der $\gets$ NULL \ComplejidadDer{1}
			\EndIf
			\State delete pNodo \Complejidad{1}
		\EndIf
	\Else
		\If{*(pNodo).izq == NULL $\wedge$ *(pNodo).der != NULL} \ComplejidadDer{1}
			%EL NODO TIENE UNA HOJA DER
			\If{*(pNodo).padre == NULL} \ComplejidadDer{1}
				\State *(*(pNodo).der).padre $\gets$ NULL \ComplejidadDer{1}
				\State  d.raiz $\gets$ *(pNodo).der \ComplejidadDer{1}
				\State delete pNodo \ComplejidadDer{1}
			\Else
				\If{*(pNodo).clave == *(*(*(pNodo).padre).izq).clave} \ComplejidadDer{1}
					\State *(*(pNodo).padre).izq $\gets$ *(pNodo).der \ComplejidadDer{1}
				\Else
					\State *(*(pNodo).padre).der $\gets$ *(pNodo).der \ComplejidadDer{1}
				\EndIf
				\State *(*(pNodo).der).padre $\gets$ *(pNodo).padre \ComplejidadDer{1}
				\State delete pNodo \ComplejidadDer{1}
			\EndIf
		\Else
			\If{*(pNodo).izq != NULL $\wedge$ *(pNodo).der == NULL}
				%EL NODO TIENE UNA HOJA IZQ
				\If{*(pNodo).padre == NULL} \ComplejidadDer{1}
					\State *(*(pNodo).izq).padre $\gets$ NULL \ComplejidadDer{1}
					\State d.raiz $\gets$ *(pNodo).izq \ComplejidadDer{1}
					\State delete pNodo \ComplejidadDer{1}
				\Else
					\If{*(pNodo).clave == *(*(*(pNodo).padre).izq).clave} \ComplejidadDer{1}
						\State *(*(pNodo).padre).izq $\gets$ *(pNodo).izq \ComplejidadDer{1}
					\Else
						\State *(*(pNodo).padre).der $\gets$ *(pNodo).izq \ComplejidadDer{1}
					\EndIf
					\State *(*(pNodo).izq).padre $\gets$ *(pNodo).padre \ComplejidadDer{1}
					\State delete pNodo \ComplejidadDer{1}
				\EndIf 
			\Else
				%EL NODO TIENE DOS HOJAS
				\If{*(pNodo).padre == NULL} \ComplejidadDer{1}
					\State var nuevoPNodo: puntero(nodo) $\gets$ *(pNodo).der \ComplejidadDer{1}
					\State nroCamino $\gets$ nroCamino + 1 \ComplejidadDer{1}
					\State camino[nroCamino] $\gets$ nuevoPNodo \ComplejidadDer{1}
					\While{*(nuevoPNodo).izq != NULL} \ComplejidadDer{log_2\ n}
						\If{*(nuevoPNodo).der == NULL} \ComplejidadDer{1}
							\State *(nuevoPNodo).alt $\gets$ *(nuevoPNodo).alt - 1 \ComplejidadDer{1}
						\Else
							\State *(nuevoPNodo).alt $\gets$ max(*(*(nuevoPNodo).izq).alt - 1, *(*(nuevoPNodo).der).alt) \ComplejidadDer{1}
						\EndIf
						\State nuevoPNodo $\gets$ *(nuevoPNodo).izq \ComplejidadDer{1}
						\State nroCamino $\gets$ nroCamino + 1 \ComplejidadDer{1}
						\State camino[nroCamino] $\gets$ nuevoPNodo \ComplejidadDer{1}
					\EndWhile
					\State *(pNodo).clave $\gets$ *(nuevoPNodo).clave \ComplejidadDer{1}
					\State *(pNodo).significado $\gets$ *(nuevoPNodo).significado \ComplejidadDer{1}
					\If{*(nuevoPNodo).der != NULL} \ComplejidadDer{1}
						\If{*(*(*(nuevoPNodo).padre).izq).clave == *(nuevoPNodo).clave} \ComplejidadDer{1}
							\State *(*(nuevoPNodo).padre).izq $\gets$ *(nuevoPNodo).der \ComplejidadDer{1}
						\Else
							\State *(*(nuevoPNodo).padre).der $\gets$ *(nuevoPNodo).der \ComplejidadDer{1}
						\EndIf
						\State *(*(nuevoPNodo).der).padre $\gets$ *(nuevoPNodo).padre \ComplejidadDer{1}
					\Else
						\If{*(*(*(nuevoPNodo).padre).izq).clave == *(nuevoPNodo).clave} \ComplejidadDer{1}
							\State *(*(nuevoPNodo).padre).izq $\gets$ NULL \ComplejidadDer{1}
						\Else
							\State *(*(nuevoPNodo).padre).der $\gets$ NULL \ComplejidadDer{1}
						\EndIf
					\EndIf
					\State delete nuevoPNodo \ComplejidadDer{1}
				\Else
				\EndIf
			\EndIf
		\EndIf
	\EndIf
	\State d.tam $\gets$ d.tam - 1 \ComplejidadDer{1}
	\State nroCamino $\gets$ nroCamino - 1 \ComplejidadDer{1}
	\While{nroCamino $\geq$ 0} \ComplejidadDer{log_2\ n}
		\State pNodo $\gets$ camino[nroCamino] \ComplejidadDer{1}
		\If{|\NombreFuncion{FactorDesbalance}(pNodo)| $>$ 1} \ComplejidadDer{1}
			\State \NombreFuncion{Rotar}(pNodo) \ComplejidadDer{1}
		\Else
		\EndIf
		\State nroCamino $\gets$ nroCamino - 1 \ComplejidadDer{1}
	\EndWhile		
}{\Complejidad{log_2\ n}}{
}

\Algoritmo{IRotar}{\Inout{p}{puntero(nodo)}}{}{
	\If{\NombreFuncion{FactorDesbalance}(p) $<$ 1} \ComplejidadDer{1}
		\If{\NombreFuncion{FactorDesbalance}(*(p).der) $>$ 1} \ComplejidadDer{1}
			\State $res$ $\gets$ \NombreFuncion{RotarDobleIzq}($p$) \ComplejidadDer{1}
		\Else 
			\State $res$ $\gets$ \NombreFuncion{RotarSimpleIzq}($p$) \ComplejidadDer{1}
		\EndIf
	\Else
		\If{\NombreFuncion{FactorDesbalance}(*(p).izq) $<$ 1} \ComplejidadDer{1}
			\State $res$ $\gets$\NombreFuncion{RotarDobleDer}($p$) \ComplejidadDer{1}
		\Else
			\State $res$ $\gets$ \NombreFuncion{RotarSimpleDer}($p$) \ComplejidadDer{1}
		\EndIf
	\EndIf
}{\Complejidad{1}}{
}

\Algoritmo{IRotarSimpleIzq}{\Inout{p}{puntero(nodo)}}{}{
	\State var r: puntero(nodo) $\gets$ p \ComplejidadDer{1}
	\State var r2: puntero(nodo) $\gets$ *(r).der \ComplejidadDer{1}
	\State var i: puntero(nodo) $\gets$ *(r).izq \ComplejidadDer{1}
	\State var i2: puntero(nodo) $\gets$ *(r2).izq \ComplejidadDer{1}
	\State var d2: puntero(nodo) $\gets$ *(r2).der \ComplejidadDer{1}
	\State var padre: puntero(nodo) $\gets$ *(r).padre \ComplejidadDer{1}
	\If{padre != NULL}
		\If{*(r).clave == *(*(padre).izq).clave} \ComplejidadDer{1}
			\State  *(padre).izq $\gets$ r2 \ComplejidadDer{1}
		\Else
			\State *(padre).der $\gets$ r2 \ComplejidadDer{1}
 		\EndIf
	\Else
	\EndIf
	\State *(r2).padre $\gets$ padre \ComplejidadDer{1}
	\State *(r2).izq $\gets$ r \ComplejidadDer{1}
	\State *(r).padre $\gets$ r2 \ComplejidadDer{1}
	\State *(r).der $\gets$ i2 \ComplejidadDer{1}
	\If{i2 != NULL}
		\State *(i2).padre $\gets$ r \ComplejidadDer{1}
	\Else
	\EndIf
	\State *(r).alt $\gets$ \NombreFuncion{Altura}(r) \ComplejidadDer{1}
	\State *(r2).alt $\gets$ \NombreFuncion{Altura}(r2) \ComplejidadDer{1}
 }{\Complejidad{1}}{
}	

\Algoritmo{IRotarSimpleDer}{\Inout{p}{puntero(nodo)}}{}{
	\State var r: puntero(nodo) $\gets$ p \ComplejidadDer{1}
	\State var r2: puntero(nodo) $\gets$ *(r).izq \ComplejidadDer{1}
	\State var d: puntero(nodo) $\gets$ *(r).der \ComplejidadDer{1}
	\State var i2: puntero(nodo) $\gets$  *(r2).izq \ComplejidadDer{1}
	\State var d2: puntero(nodo) $\gets$ *(r2).der \ComplejidadDer{1}
	\State var padre: puntero(nodo) $\gets$ *(r).padre \ComplejidadDer{1}
	\If{padre != NULL}
		\If{*(r).clave == *(*(padre).izq).clave} \ComplejidadDer{1}
			\State  *(padre).izq $\gets$ r2 \ComplejidadDer{1}
		\Else
			\State *(padre).der $\gets$ r2 \ComplejidadDer{1}
 		\EndIf
	\Else
	\EndIf	
	\State *(r2).padre $\gets$ padre \ComplejidadDer{1}
	\State *(r2).der $\gets$ r \ComplejidadDer{1}
	\State *(r).padre $\gets$ r2 \ComplejidadDer{1}
	\State *(r).izq $\gets$ d2 \ComplejidadDer{1}
	\If{d2 != NULL}
		\State *(d2).padre $\gets$ r \ComplejidadDer{1}
 	\Else
	\EndIf
	\State *(r).alt $\gets$ \NombreFuncion{Altura}(r) \ComplejidadDer{1}
	\State *(r2).alt $\gets$ \NombreFuncion{Altura}(r2) \ComplejidadDer{1}
}{\Complejidad{1}}{
}	

\Algoritmo{IRotarDobleIzq}{\Inout{p}{puntero(nodo)}, \Inout{d}{diccRapido}}{}{
	\State \NombreFuncion{RotarSimpleDer}(*(p).der) \ComplejidadDer{1}
	\State \NombreFuncion{RotarSimpleIzq}(p) \ComplejidadDer{1}
}{\Complejidad{1}}{
}	

\Algoritmo{IRotarDobleDer}{\Inout{p}{puntero(nodo)}}{}{
	\State \NombreFuncion{RotarSimpleIzq}(*(p).izq) \ComplejidadDer{1}
	\State \NombreFuncion{RotarSimpleDer}(p) \ComplejidadDer{1}
}{\Complejidad{1}}{
}	

\Algoritmo{IAltura}{\In{p}{puntero(nodo)}}{nat}{
	\If{*(p).izq == NULL $\wedge$ *(p).der == NULL} \ComplejidadDer{1}
		\State $\res$ $\gets$ 1 \ComplejidadDer{1}
	\Else
		\If{*(p).izq != NULL $\wedge$ *(p).der == NULL} \ComplejidadDer{1}
			\State $\res$ $\gets$ *(*(p).izq).alt + 1 \ComplejidadDer{1}
		\Else
			\If{*(p).izq == NULL $\wedge$ *(p).der != NULL} \ComplejidadDer{1}
				\State $res$ $\gets$ *(*(p).der).alt + 1 \ComplejidadDer{1}
			\Else
				\State $res$ $\gets$ max(*(*(p).izq).alt, *(*(p).der).alt) + 1 \ComplejidadDer{1}
			\EndIf
		\EndIf
	\EndIf
}{\Complejidad{1}}{
}

\Algoritmo{IFactorDesbalance}{\In{p}{puntero(nodo)}}{nat}{
		\If{*(p).izq == NULL $\wedge$ *(p).der == NULL} \ComplejidadDer{1}
		\State $\res$ $\gets$ 0 \ComplejidadDer{1}
	\Else
		\If{*(p).izq != NULL $\wedge$ *(p).der == NULL} \ComplejidadDer{1}
			\State $\res$ $\gets$ *(*(p).izq).alt \ComplejidadDer{1}
		\Else
			\If{*(p).izq == NULL $\wedge$ *(p).der != NULL} \ComplejidadDer{1}
				\State $res$ $\gets$ - *(*(p).der).alt \ComplejidadDer{1}
			\Else
				\State $res$ $\gets$ *(*(p).izq).alt - *(*(p).der).alt \ComplejidadDer{1}
			\EndIf
		\EndIf
	\EndIf
}{\Complejidad{1}}{
}

\Algoritmo{IVacío?}{\In{d}{diccRapido}}{bool}{
	\If{d.raiz == NULL} \ComplejidadDer{1}
		\State $res$ $\gets$ true \ComplejidadDer{1}
	\Else
		\State $res$ $\gets$ false \ComplejidadDer{1}
	\EndIf	
}{\Complejidad{1}}{
}

\Algoritmo{IDameMax}{\In{d}{diccRapido}}{clave}{
	\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
	\While{*(pNodo).der != NULL} \ComplejidadDer{log_2\ n}
		\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
	\EndWhile
	\State $res$ $\gets$ *(pNodo).clave \ComplejidadDer{1}
}{\Complejidad{log_2\ n}}{
}
%% la tupla es (0: nivel, 1: numero de nodo, 2: total de nodos, 3: actual, 4: raiz)
\Algoritmo{ICrearIt}{\In{d}{diccRapido}}{itClaves}{
	\State $res$ $\gets$ tupla(1, 0, d.tam, d.raiz, d.raiz) \ComplejidadDer{1}
}{\Complejidad{1}}{
}

\Algoritmo{IHayMas?}{\In{it}{itClaves}}{bool}{
	\If{it.1, $\textless$ it.2 - 1} \ComplejidadDer{1}
		\State $res$ $\gets$ true \ComplejidadDer{1}
	\Else
		\State $res$ $\gets$ false \ComplejidadDer{1}
	\EndIf
}{\Complejidad{1}}{
}

\Algoritmo{Actual}{\In{it}{itClaves}}{clave}{
	\State $res$ $\gets$ it.3 \ComplejidadDer{1}
}{\Complejidad{1}}{
}

\Algoritmo{Avanzar}{\Inout{it}{itClaves}}{}{
	\State it.1 $\gets$ it.1 + 1 \ComplejidadDer{1}
	\State var itNodosNivelActual $\gets$ \NombreFuncion{crearIt}(\NombreFuncion{DameNodos}(it.4, 1, it.0)) \ComplejidadDer{1}
	\State var bAvanzar:bool $\gets$ true 
	\While{\NombreFuncion{HaySiguiente?}(itNodosNivelActual) $\wedge$ bAvanzar}
		\State \NombreFuncion{Avanzar}(itNodosNivelActual) \ComplejidadDer{1}
		\If{\NombreFuncion{Anterior}(itNodosNivelActual) == \NombreFuncion{Actual}(it)} \ComplejidadDer{1}
			\If{\NombreFuncion{HaySiguiente?}(itNodosNivelActual)} \ComplejidadDer{1}
				\State it.3 $\gets$ \NombreFuncion{Siguiente}(itNodosNivelActual) \ComplejidadDer{1}
				\State bAvanzar $\gets$ false \ComplejidadDer{1}
			\Else
				\State it.0 $\gets$ it.0 + 1 \ComplejidadDer{1}
				\State it.3 $\gets$ \NombreFuncion{Siguiente}(\NombreFuncion{crearIt}(DameNodos(it.4, 1, it.0))) \ComplejidadDer{1}
			\EndIf
		\Else
		\EndIf
	\EndWhile
}{\Complejidad{1}}{
}

\Algoritmo{DameNodos}{\In{p}{puntero(nodo)}, \In{actual}{nat}, \In{destino}{nat}}{Conj(nodo)}{
	\State $res$ $\gets$ \NombreFuncion{Vacío}() \ComplejidadDer{1}
	\If{p == NULL} \ComplejidadDer{1}
	\Else
		\If{actual == destino} \ComplejidadDer{1}
			\State \NombreFuncion{AgregarAtrás}($res$ , p) \ComplejidadDer{1}
		\Else
			\State \NombreFuncion{Union}(\NombreFuncion{DameNodos}(*(p).izq, actual + 1, destino), \NombreFuncion{DameNodos}(*(p).der, actual + 1, destino)) \ComplejidadDer{1}
		\EndIf
	\EndIf
}{\Complejidad{1}}{
}	



\end{Algoritmos}




