\section{Diccionario Rápido}

\subsection{Interfaz}

\begin{Interfaz}

 \textbf{parámetros formales}: $\alpha$, $\beta$; $\alpha$ tiene relación de orden
  
  \textbf{se explica con}: \tadNombre{Diccionario(clave, significado)}, \tadNombre{iterador unidireccional($\alpha$)}

  \textbf{géneros}: \TipoVariable{diccRapido($\alpha$,$\beta$)}, \tadNombre{itClave($\alpha$)}

  \Titulo{Operaciones básicas de Diccionario Rápido($\alpha$,$\beta$)}

  \InterfazFuncion{Def?}{\In{c}{$\alpha$}, \In{d}{diccRapido($\alpha$,$\beta$)}}{bool}
  [true]
  {$res$ $\igobs$ def?($c, d$)}
  [\Complejidad{log_2\ n}, siendo n la cantidad de claves]
  [Verifica si una clave está definida.]
  
 \InterfazFuncion{Obtener}{\In{c}{$\alpha$}, \In{d}{diccRapido($\alpha$,$\beta$)}}{$\beta$}
 [def?($c, d$)]
 {$res$ $\igobs$ obtener($c, d$)}
 [$\Complejidad{log_2\ n}$, siendo n la cantidad de claves]
 [Devuelve el significado asociado a una clave]
 [res es modificable si y sólo si d es modificable]
  
 \InterfazFuncion{Vacío}{}{diccRapido($\alpha$,$\beta$)}
 [true]
 {$res$ $\igobs$ vacío()}
 [$\Complejidad{1}$]
 [Crea un nuevo diccionario vacío]  
  
 \InterfazFuncion{Definir}{\In{c}{$\alpha$}, \In{s}{$\beta$}, \Inout{d}{diccRapido($\alpha$,$\beta$)}}{}
 [$d$ $\igobs$ $d_0$]
 {$d$ $\igobs$ definir($c, s, d_0$)}
 [$\Complejidad{log_2\ n}$, siendo n la cantidad de claves]
 [Define la clave, asociando su significado, al diccionario]
 [Los elementos c y s se definen por referencia. ]
  
 \InterfazFuncion{Borrar}{\In{c}{$\alpha$}, \Inout{d}{diccRapido($\alpha$,$\beta$)}}{}
 [$d$ $\igobs$ $d_0$ $\wedge$ def?($c, d_0$)]
 {$d$ $\igobs$ borrar($c, d_0$)}
 [$\Complejidad{log_2\ n}$, siendo n la cantidad de claves]
 [Borra la clave del diccionario]
  
 \InterfazFuncion{Vacío?}{\In{d}{diccRapido($\alpha$,$\beta$)}}{bool}
 [true]
 {$res$ $\igobs$ vacío?($d$)}
 [$\Complejidad{1}$]
 [Verifica si el diccionario vacío]
 
 \InterfazFuncion{ClaveMax}{\In{d}{diccRapido($\alpha$,$\beta$)}}{$\alpha$}
 [$\neg$vacío?(d)]
 {$res$ $\igobs$ claveMax($d$)}
 [$\Complejidad{log_2\ n}$]
 [Devuelve la mayor clave]
 [res es modificable si y sólo si d es modificable]
  
 \InterfazFuncion{Claves}{\In{d}{diccRapido($\alpha$,$\beta$)}}{itClave}
 [true]
 {$res$ $\igobs$ CrearIt(claves($d$))}
 [$\Complejidad{1}$]
 [Devuelve un iterador de paquete]  
 
 \Titulo{Operaciones del Iterador}
 
 \InterfazFuncion{CrearIt}{\In{d}{diccRapido($\alpha$,$\beta$)}}{itClave}
 [true]
 {$res$ $\igobs$ crearItUni(secuClaves(d))}
 [$\Complejidad{1}$]
 [Crea el iterador de claves]
 
 \InterfazFuncion{HayMas?}{\In{it}{itClave}}{bool}
 [true]
 {$res$ $\igobs$ HayMas?($it$)}
 [$\Complejidad{1}$]
 [Verifica si hay más elementos a iterar]
 
 \InterfazFuncion{Actual}{\In{it}{itClave}}{$\alpha$}
 [HayMas?($it$)]
 {$res$ Actual($it$)}
 [$\Complejidad{1}$]
 [Devuelve el actual del iterador]
 
 \InterfazFuncion{Avanzar}{\Inout{it}{itClave}}{}
 [$it$ $\igobs$ $it_0$ $\wedge$ HayMas?($it_0$)]
 {$it$ $\igobs$ Avanzar($it_0$)} 
 [$\Complejidad{n}$]
 [Avanza el iterador]
  
  \subsection{Auxiliares}
	%\Begin{Auxiliares}
  \Titulo{Operaciones auxiliares}

	
 \InterfazFuncion{DameNodos}{\In{p}{puntero(nodo)}, \In{actual}{nat}, \In{destino}{nat}}{conjLineal(nodo)}
 [true]
 {$res$ $\igobs$ nodosNivel($p, actual, destino$)}
 [$\Complejidad{n}$]
 [Crea un conjunto de nodos con todos los nodos pertenecientes al nivel destino]
 
 \InterfazFuncion{Rotar}{\Inout{p}{puntero(nodo)}}{}
 [$p$ $\igobs$ $p_0$ $\wedge$ p != NULL $\yluego$ (|\tadNombre{FactorDesbalance}(p)| $>$ 1)]
 {$p$ $\igobs$ rotar($p_0$)}
 [$\Complejidad{1}$]
 [Realiza la rotación pertinente de p, de ser necesario]
 
 \InterfazFuncion{RotarSimpleIzq}{\Inout{p}{puntero(nodo)}}{}
 [$p$ $\igobs$ $p_0$ $\wedge$ p != NULL $\yluego$ *(p).der != NULL]
 {$p$ $\igobs$ rotarSimpleIzq($p_0$)}
 [$\Complejidad{1}$]
 [Realiza una rotación simple izquierda del nodo p, y los nodos involucrados] 

 \InterfazFuncion{RotarSimpleDer}{\Inout{p}{puntero(nodo)}}{}
 [$p$ $\igobs$ $p_0$ $\wedge$ p != NULL $\yluego$ *(p).izq != NULL]
 {$p$ $\igobs$ rotarSimpleDer($p_0$)}
 [$\Complejidad{1}$]
 [Realiza una rotación simple derecha del nodo p, y los nodos involucrados]
 
 \InterfazFuncion{RotarDobleIzq}{\Inout{p}{puntero(nodo)}}{}
 [$p$ $\igobs$ $p_0$ $\wedge$ p != NULL $\yluego$ *(p).der !=NULL $\yluego$ *(*(p).der).izq != NULL]
 {$p$ $\igobs$ rotarDobleIzq($p_0$)}
 [$\Complejidad{1}$]
 [Realiza una rotación doble izquierda del nodo p, y los nodos involucrados]
 
 \InterfazFuncion{RotarDobleDer}{\Inout{p}{puntero(nodo)}}{}
 [$p$ $\igobs$ $p_0$ $\wedge$ p != NULL $\yluego$ *(p).izq != NULL $\yluego$ *(*(p).izq).der != NULL]
 {$p$ $\igobs$ rotarDobleDer($p_0$)}
 [$\Complejidad{1}$]
 [Realiza una rotación doble derecha del nodo p, y los nodos involucrados]
 
 \InterfazFuncion{Altura}{\In{p}{puntero(nodo)}}{nat}
 [p != NULL]
 {$res$ $\igobs$ altura(p)}
 [$\Complejidad{1}$]
 [Calcula y devuelve la altura actual de p]
 
 \InterfazFuncion{FactorDesbalance}{\In{p}{puntero(nodo)}}{nat}
 [p != NULL]
 {$res$ $\igobs$ factorDesbalance(p)}
 [$\Complejidad{1}$]
 [Calcula y devuelve el factor de desbalance actual de p]


\end{Interfaz}

\subsection{Representación}

\begin{Representacion}

\textbf{Representación del Diccionario}
\vspace{1em}

Como se sabe que la cantidad de claves no está acotada, este diccionario estará representado con un AVL. Cabe destacar, que las claves del diccionario deben contener una relación de orden. 

\begin{Estructura}{diccRapido($\alpha$,$\beta$)}[estr]
	\begin{Tupla}[estr]
		\tupTupItem{raiz}{\TipoVariable{puntero}(nodo)}
		\tupItem{tam}{nat}
		%\tupItem{cVac}{bool}
	\end{Tupla}
	
	\begin{Tupla}[nodo]
		\tupItem{clave}{$\alpha$}
		\tupItem{significado}{$\beta$}
		\tupTupItem{padre}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{izq}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{der}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{alt}{\TipoVariable{nat}}
	\end{Tupla}
	
\end{Estructura}

\textbf{Representación del Iterador}
\vspace{1em}

\begin{Estructura}{itClave}[estr]
	\begin{Tupla}[estr]
		\tupItem{nivel actual}{nat}
		\tupItem{$\#$nodos recorridos}{nat}
		\tupItem{$\#$nodos}{nat}
		\tupTupItem{actual}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{raiz}{\TipoVariable{puntero}(nodo)}
	\end{Tupla}	
	
		\begin{Tupla}[nodo]
		\tupItem{clave}{$\alpha$}
		\tupItem{significado}{$\beta$}
		\tupTupItem{padre}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{izq}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{der}{\TipoVariable{puntero}(nodo)}
		\tupTupItem{alt}{\TipoVariable{nat}}
	\end{Tupla}

\end{Estructura}


\subsection{InvRep y Abs}

\textbf{InvRep en lenguaje coloquial:}

\begin{enumerate}
	\item{La componente ''tam'' es igual a la cantidad de nodos del árbol.}
	\item{Todo nodo del árbol tiene padre, con excepción de la raíz, que no tiene padre. Y de tener padre, como máximo, puede existir otro nodo que tenga el mismo padre.}
	\item{No puede haber un nodo que sea hijo de dos nodos distintos.}
	\item{Un nodo (n1) tiene a otro nodo (n2) como hijo (ya sea izquierdo, o derecho), si y solo si n2 tiene a n1 como padre.}
	\item{Un nodo no puede tener al mismo hijo izquierdo y derecho. Tampoco puede tenerse a sí mismo como padre, o hijo izquierdo, o derecho.}
	\item{La relación de orden es total.}
	\item{No hay dos nodos con la misma componente ''clave''.}
	\item{Para todo nodo, todos los nodos de su subárbol derecho son mayores a él.}
	\item{Para todo nodo, todos los nodos del su subárbol izquierdo son menores que él.}
	\item{La componente ''alt'' de cada nodo es igual a la cantidad de nodos que hay que ''bajar'' para llegar a su hoja mas lejana + 1. 		Vale aclarar que el nodo hoja tiene la componente ''alt'' igual a 1.}
	\item{Para todo nodo, la diferencia,  en módulo,  de la altura entre sus subárboles es menor o igual a 1.}
	\item{Siempre existe un camino entre la raíz y cualquier otro nodo.}
	\item{No hay ciclos. Más formalmente, partiendo de un nodo, no se puede volver a pasar por él sin utilizar la operación padre.}
\end{enumerate}

\textbf{Abs:}

\vspace{1em}

\Abs[estr]{Diccionario(Clave, Significado)}[e]{d}{
		\\ ($\forall$c: clave) 
		\\ def?(c, d) = Def?(c, e) $\yluego$  
		\\ obtener(c, d) = Obtener(c, e)
}


\end{Representacion}

\subsection{Algoritmos}

\begin{Algoritmos}

\Algoritmo{IDef?}{\In{c}{$\alpha$}, \In{d}{diccRapido($\alpha$,$\beta$)}}{bool}{
	\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
	\While{pNodo != NULL} \ComplejidadDer{log_2\ n * k}
		\If{*(pNodo).clave == c} \ComplejidadDer{k}
			\State $res$ $\gets$ true \ComplejidadDer{1}
			\State return $res$ \ComplejidadDer{1}
		\Else
			\If{c $\textgreater$ *(pNodo).clave} \ComplejidadDer{k}
				\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
			\Else
				\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
			\EndIf	
		\EndIf		
	\EndWhile
	\State $res$ $\gets$ false \ComplejidadDer{1}
	}{\Complejidad{log_2\ n * k}}{Siendo n la cantidad de nodos y k el costo de comparación de $\alpha$. \\ Vamos a ignorar las asignaciones, dado que éstas siempre ocurren en tiempo constante. Para analizar la complejidad del ciclo, es necesario tomar en cuenta cuantas iteraciones (como máximo) haría éste antes de romper su guarda y cuánto cuesta cada una. Como se trata de buscar un nodo en un AVL, sabemos que la búsqueda es \Complejidad{log_2\ n * k}, dado que el árbol está balanceado, es decir, en el peor caso estaremos buscando un nodo que puede pertenecer (o no) al último nivel y por esto se debe descender \Complejidad{log_2\ n} veces. Luego, cada iteración cuesta \Complejidad{k}. Finalmente, la complejidad del ciclo es la que define la complejidad del algoritmo.
}

\Algoritmo{IObtener}{\In{c}{$\alpha$}, \In{d}{diccRapido($\alpha$,$\beta$)}}{$\beta$}{
	\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
	\While{*(pNodo).clave != c} \ComplejidadDer{log_2\ n * k}
		\If{c $\textgreater$ *(pNodo).clave} \ComplejidadDer{k}
			\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
		\Else
			\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
		\EndIf			
	\EndWhile
	\State $res$ $\gets$ *(pNodo).significado \ComplejidadDer{1}
	}{\Complejidad{log_2\ n * k}}{Siendo n la cantidad de nodos y k el costo de comparación de $\alpha$. \\ Es un algoritmo muy parecido al de \NombreFuncion{Def?}. Nuevamente ignoraremos las asignaciones, dado que éstas siempre ocurren en tiempo constante. Para analizar la complejidad del ciclo, es necesario tomar en cuenta cuantas iteraciones (como máximo) haría éste antes de romper su guarda y cuánto cuesta cada una. Como se trata de buscar un nodo en un AVL, sabemos que la búsqueda es \Complejidad{log_2\ n * k}, dado que el árbol está balanceado, es decir, en el peor caso estaremos buscando un nodo que puede pertenecer (o no) al último nivel y por esto se debe descender \Complejidad{log_2\ n} veces. Luego, cada iteración cuesta \Complejidad{k}. Finalmente, la complejidad del ciclo es la que define la complejidad del algoritmo.
}
	
\Algoritmo{IVacío}{}{diccRapido($\alpha$,$\beta$)}{
	\State var $res$: diccRapido($\alpha$,$\beta$) $\gets$ tupla(NULL, 0) \ComplejidadDer{1}
}{\Complejidad{1}}{
}	

\Algoritmo{IDefinir}{\In{c}{$\alpha$}, \In{s}{$\beta$}, \Inout{d}{diccRapido($\alpha$,$\beta$)}}{}{
	\State \If{d.raiz == NULL} \ComplejidadDer{1}
			\State d.raiz $\gets$ $\&$tupla(c, s, NULL, NULL, NULL, 1) \ComplejidadDer{1}
		  	\State d.tam $\gets$ 1 \ComplejidadDer{1}
		  \Else
		  	\If{\NombreFuncion{Def?}(c, d)} \ComplejidadDer{log_2\ n * k}
				\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
				\While{*(pNodo).clave != c} \ComplejidadDer{log_2\ n * k}
					\If{c $\textgreater$ *(pNodo).clave} \ComplejidadDer{k}
						\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
					\Else
						\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
					\EndIf			
				\EndWhile
				\State *(pNodo).significado $\gets$ s \ComplejidadDer{1}
			\Else
		  		\State var	seguir: bool $\gets$ true \ComplejidadDer{1}
				\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
				\While{seguir == true} \ComplejidadDer{log2\ n * k}
					\If{c $\textgreater$ *(pNodo).clave $\wedge$ *(pNodo).der == NULL} \ComplejidadDer{k}
						 	\State *(pNodo).der $\gets$ $\&$tupla(c, s, pNodo, NULL, NULL, 1) \ComplejidadDer{1}
							\State seguir $\gets$ false \ComplejidadDer{1}
							
				        \Else
					  		\If{c $\textgreater$ *(pNodo).clave $\wedge$ *(pNodo).der != NULL} \ComplejidadDer{k}
								\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}		
							\Else
								\If{c $\textless$ *(pNodo).clave $\wedge$ *(pNodo).izq == NULL} \ComplejidadDer{k}
									\State *(pNodo).izq $\gets$ $\&$tupla(c, s, pNodo, NULL, NULL, 1) \ComplejidadDer{1}
									\State seguir $\gets$ false \ComplejidadDer{1}
 								\Else
									\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
								\EndIf
							\EndIf	
				        \EndIf
				\EndWhile
				\State d.tam $\gets$ d.tam + 1 \ComplejidadDer{1}
				\While{pNodo != NULL} \ComplejidadDer{log2\ n * k}
					\State var padrePNodo $\gets$ *(pNodo).padre \ComplejidadDer{1}
					\If{|\NombreFuncion{FactorDesbalance}(pNodo)| $>$ 1} \ComplejidadDer{1}
						\State \NombreFuncion{Rotar}(pNodo) \ComplejidadDer{k}
					\Else
						\State *(pNodo).alt $\gets$ \NombreFuncion{Altura}(pNodo) \ComplejidadDer{1}
					\EndIf
					\State pNodo $\gets$ padrePNodo \ComplejidadDer{1}
 				\EndWhile
			\EndIf			
		  \EndIf
}{\Complejidad{log_2\ n * k}}{Siendo n la cantidad de nodos, y k el costo de comparación de $\alpha$. \\ En este algoritmo, tomaremos en cuenta las complejidades de tres casos e ignoraremos las asignaciones (dado que son constantes). 
\\ -El primer caso es cuando se quiera definir en un diccionario vacío, esto es \Complejidad{1}+\Complejidad{1}+\Complejidad{1} = 3 * \Complejidad{1} = \Complejidad{1} 
\\ -El segundo caso es cuando se quiera definir una clave que ya estaba definida previamente, aquí ignoraremos las asignaciones (cuyas complejidades son \Complejidad{1}), y nos centraremos en el uso de \NombreFuncion{Def?} y el ciclo. \NombreFuncion{Def?} sabemos que toma \Complejidad{log_2\ n * k}, y en cuanto al ciclo, sabemos que tomará \Complejidad{log_2\ n * k} también, porque iterará hasta buscar el nodo buscado (itera \Complejidad{log_2\ n} veces) y cada iteración cuesta \Complejidad{k}. Esto es: \Complejidad{log_2\ n * k} + \Complejidad{log_2\ n * k} = 2 * \Complejidad{log_2\ n * k} = \Complejidad{log_2\ n * k}
\\ -El tercer caso es cuando se quiera definir una clave que no estaba definida anteriormente. Nuevamente ignoraremos las asignaciones, y nos centraremos en los dos ciclos. El primer ciclo consiste en iterar hasta llegar a la posición donde queremos insertar el nuevo nodo, nuevamente esto es \Complejidad{log_2\ n * k} porque en peor caso tendríamos que descender hasta la hoja más lejana. Por último, el segundo ciclo recorre, de abajo hacia arriba, la rama por la que acabamos de bajar, y dado que como ya mencionamos que ésta tiene (a lo sumo) $log_2\ n$ elementos, esto es \Complejidad{log_2\ n}. Finalmente, dado que este caso tiene éstas tres complejidades no anidadas: \Complejidad{log_2\ n}+\Complejidad{log_2\ n}+\Complejidad{log_2\ n} = 3 * \Complejidad{log_2\ n} = \Complejidad{log_2\ n}.
\\ -Ahora, como teníamos tres casos, la complejidad es el máximo de ellos: max(\Complejidad{1},\Complejidad{log_2\ n},\Complejidad{log_2\ n}) = \Complejidad{log_2\ n}

}

\Algoritmo{IBorrar}{\In{c}{$\alpha$}, \Inout{d}{diccRapido($\alpha$,$\beta$)}}{}{
	\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
	\While{c != *(pNodo).clave} \ComplejidadDer{log_2\ n * k}
		\If{c $\textgreater$ *(pNodo).clave} \ComplejidadDer{k}
			\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
		\Else
			\State pNodo $\gets$ *(pNodo).izq \ComplejidadDer{1}
		\EndIf			
	\EndWhile
	\If{*(pNodo).izq == NULL $\wedge$ *(pNodo).der == NULL} \ComplejidadDer{1}
		%EL NODO NO TIENE HOJAS
		\If{*(pNodo).padre == NULL} \ComplejidadDer{1}
			\State d.raiz $\gets$ NULL \ComplejidadDer{1}
		\Else
			\If{pNodo == *(*(pNodo).padre).izq} \ComplejidadDer{k}
				\State *(*(pNodo).padre).izq $\gets$ NULL \ComplejidadDer{1}
			\Else
				\State *(*(pNodo).padre).der $\gets$ NULL \ComplejidadDer{1}
			\EndIf
		\EndIf
	\Else
		\If{*(pNodo).izq == NULL $\wedge$ *(pNodo).der != NULL} \ComplejidadDer{1}
			%EL NODO TIENE UNA HOJA DER
			\If{*(pNodo).padre == NULL} \ComplejidadDer{1}
				\State *(*(pNodo).der).padre $\gets$ NULL \ComplejidadDer{1}
				\State  d.raiz $\gets$ *(pNodo).der \ComplejidadDer{1}
			\Else
				\If{pNodo == *(*(pNodo).padre).izq} \ComplejidadDer{k}
					\State *(*(pNodo).padre).izq $\gets$ *(pNodo).der \ComplejidadDer{1}
				\Else
					\State *(*(pNodo).padre).der $\gets$ *(pNodo).der \ComplejidadDer{1}
				\EndIf
				\State *(*(pNodo).der).padre $\gets$ *(pNodo).padre \ComplejidadDer{1}
			\EndIf
		\Else
			\If{*(pNodo).izq != NULL $\wedge$ *(pNodo).der == NULL} \ComplejidadDer{1}
				%EL NODO TIENE UNA HOJA IZQ
				\If{*(pNodo).padre == NULL} \ComplejidadDer{1}
					\State *(*(pNodo).izq).padre $\gets$ NULL \ComplejidadDer{1}
					\State d.raiz $\gets$ *(pNodo).izq \ComplejidadDer{1}
				\Else
					\If{pNodo == *(*(pNodo).padre).izq} \ComplejidadDer{k}
						\State *(*(pNodo).padre).izq $\gets$ *(pNodo).izq \ComplejidadDer{1}
					\Else
						\State *(*(pNodo).padre).der $\gets$ *(pNodo).izq \ComplejidadDer{1}
					\EndIf
					\State *(*(pNodo).izq).padre $\gets$ *(pNodo).padre \ComplejidadDer{1}
				\EndIf 
			\Else
				%EL NODO TIENE DOS HOJAS
				\State var nuevoPNodo: puntero(nodo) $\gets$ *(pNodo).der \ComplejidadDer{1}
				\While{*(nuevoPNodo).izq != NULL} \ComplejidadDer{log_2\ n * k}
					\State nuevoPNodo $\gets$ *(nuevoPNodo).izq \ComplejidadDer{1}
				\EndWhile
				\State *(pNodo).clave $\gets$ *(nuevoPNodo).clave \ComplejidadDer{1}
				\State *(pNodo).significado $\gets$ *(nuevoPNodo).significado \ComplejidadDer{1}
				\If{*(nuevoPNodo).der != NULL} \ComplejidadDer{1}
					\If{*(*(nuevoPNodo).padre).izq == nuevoPNodo} \ComplejidadDer{k}
						\State *(*(nuevoPNodo).padre).izq $\gets$ *(nuevoPNodo).der \ComplejidadDer{1}
					\Else
						\State *(*(nuevoPNodo).padre).der $\gets$ *(nuevoPNodo).der \ComplejidadDer{1}
					\EndIf
					\State *(*(nuevoPNodo).der).padre $\gets$ *(nuevoPNodo).padre \ComplejidadDer{1}
				\Else
					\If{*(*(nuevoPNodo).padre).izq == nuevoPNodo} \ComplejidadDer{k}
						\State *(*(nuevoPNodo).padre).izq $\gets$ NULL \ComplejidadDer{1}
					\Else
						\State *(*(nuevoPNodo).padre).der $\gets$ NULL \ComplejidadDer{1}
					\EndIf
				\EndIf
			\EndIf
		\EndIf
	\EndIf
	\State d.tam $\gets$ d.tam - 1 \ComplejidadDer{1}
	\State pNodo $\gets$ *(nuevoPNodo).padre \ComplejidadDer{1}
	\While{pNodo != NULL} \ComplejidadDer{log_2\ n * k}
		\State var padrePNodo $\gets$ *(pNodo).padre \ComplejidadDer{1}
		\If{|\NombreFuncion{FactorDesbalance}(pNodo)| $>$ 1} \ComplejidadDer{1}
			\State \NombreFuncion{Rotar}(pNodo) \ComplejidadDer{k}
		\Else
			\State *(pNodo).alt $\gets$ \NombreFuncion{Altura}(pNodo) \ComplejidadDer{1}
		\EndIf
		\State pNodo $\gets$ padrePNodo \ComplejidadDer{1}
	\EndWhile		
}{\Complejidad{log_2\ n * k}}{Siendo n la cantidad de nodos. 
\\ Nuevamente ignoraremos los condicionales y asignaciones (dado que son constantes), y nos centraremos en los tres ciclos. 
\\ -El primer ciclo consiste en buscar el elemento a borrar, dado que es una búsqueda en un AVL, esto es \Complejidad{log_2\ n}.
\\ -El segundo ciclo sucede sólo cuando el elemento a borrar tiene dos subárboles hijos distintos de NULL, esto consiste en buscar el sucesor in-order (es decir, bajar un nodo a la derecha, y luego bajar lo máximo posible hacia la izquierda. Así se encuentra el siguiente ''inmediato''). Dado que es una búsqueda, y se empieza a descender desde el nodo a borrar (en peor caso, se empieza desde la raíz), esto toma \Complejidad{log_2\ n}. Cabe aclarar que éste ciclo no siempre se ejecuta, pero dado que en los demás casos la complejidad es de \Complejidad{1}, podemos asumir que dado el caso que haya sido, estará acotado por la complejidad del peor, osea éste.
\\ -El tercer ciclo consiste en recorrer, de abajo hacia arriba, la rama en la cual se borró el nodo auxiliar buscado (e ir rotando según corresponda), esto toma \Complejidad{log_2\ n}.
\\ -Finalmente, la complejidad total es la suma de todos estas complejidades parciales: \Complejidad{log_2\ n}+\Complejidad{log_2\ n}+\Complejidad{log_2\ n} = 3 * \Complejidad{log_2\ n} = \Complejidad{log_2\ n}
}

\Algoritmo{IVacío?}{\In{d}{diccRapido($\alpha$,$\beta$)}}{bool}{
	\If{d.raiz == NULL} \ComplejidadDer{1}
		\State $res$ $\gets$ true \ComplejidadDer{1}
	\Else
		\State $res$ $\gets$ false \ComplejidadDer{1}
	\EndIf	
}{\Complejidad{1}}{
}

\Algoritmo{IClaveMax}{\In{d}{diccRapido($\alpha$,$\beta$)}}{$\alpha$}{
	\State var pNodo: puntero(nodo) $\gets$ d.raiz \ComplejidadDer{1}
	\While{*(pNodo).der != NULL} \ComplejidadDer{log_2\ n}
		\State pNodo $\gets$ *(pNodo).der \ComplejidadDer{1}
	\EndWhile
	\State $res$ $\gets$ *(pNodo).clave \ComplejidadDer{1}
}{\Complejidad{log_2\ n}}{Siendo n la cantidad de nodos. Ignorando las asignaciones, vemos que lo único a calcular es la cantidad de iteraciones del ciclo. Dado que el ciclo es una búsqueda en un AVL (en particular, se busca el elemento más grande), éste tomará a lo sumo $log_2\ n$ iteraciones.
}

\Algoritmo{IClaves}{\In{d}{diccRapido($\alpha$,$\beta$)}}{itClave}{
	\State $res$ $\gets$ \NombreFuncion{CrearIt}(d) \ComplejidadDer{1}
}{\Complejidad{1}}{
}

%% la tupla es (0: nivel, 1: numero de nodo, 2: total de nodos, 3: actual, 4: raiz)
\Algoritmo{ICrearIt}{\In{d}{diccRapido($\alpha$,$\beta$)}}{itClave}{
	\State $res$ $\gets$ tupla(1, 0, d.tam, d.raiz, d.raiz) \ComplejidadDer{1}
}{\Complejidad{1}}{
}

\Algoritmo{IHayMas?}{\In{it}{itClave}}{bool}{
	\If{it.1, $\textless$ it.2 - 1} \ComplejidadDer{1}
		\State $res$ $\gets$ true \ComplejidadDer{1}
	\Else
		\State $res$ $\gets$ false \ComplejidadDer{1}
	\EndIf
}{\Complejidad{1}}{
}

\Algoritmo{IActual}{\In{it}{itClave}}{$\alpha$}{
	\State $res$ $\gets$ *(it.3).clave \ComplejidadDer{1}
}{\Complejidad{1}}{
}

\Algoritmo{IAvanzar}{\Inout{it}{itClave}}{}{
	\State it.1 $\gets$ it.1 + 1 \ComplejidadDer{1}
	\State var itNodosNivelActual $\gets$ \NombreFuncion{crearIt}(\NombreFuncion{DameNodos}(it.4, 1, it.0)) \ComplejidadDer{n}
	\State var bAvanzar:bool $\gets$ true \ComplejidadDer{1}
	\While{bAvanzar} \ComplejidadDer{n}
		\State \NombreFuncion{Avanzar}(itNodosNivelActual) \ComplejidadDer{1}
		\If{\NombreFuncion{Anterior}(itNodosNivelActual) == \NombreFuncion{Actual}(it)} \ComplejidadDer{1}
			\State bAvanzar $\gets$ false \ComplejidadDer{1}
		\Else
		\EndIf
	\EndWhile
	\If{\NombreFuncion{HaySiguiente?}(itNodosNivelActual)} \ComplejidadDer{1}
		\State it.3 $\gets$ \NombreFuncion{Siguiente}(itNodosNivelActual) \ComplejidadDer{1}
	\Else
	\State it.0 $\gets$ it.0 + 1 \ComplejidadDer{1}
	\State it.3 $\gets$ \NombreFuncion{Siguiente}(\NombreFuncion{crearIt}(DameNodos(it.4, 1, it.0))) \ComplejidadDer{n}
	\EndIf
}{\Complejidad{n}}{Siendo n la cantidad de nodos. 
\\ el ciclo busca encontrar el nodo en donde se encuentra el iterador, para eso avanza el nuevo iterador creado, que itera un conjunto de nodos -estos nodos son todos los del nivel al que pertence el iterador buscado-. En el peor caso este conjunto es de n / 2 elementos, porque sería el nivel más bajo. Por eso tiene complejidad \Complejidad{n}. Además se le agrega a la complejidad total, la complejidad de llamar a \NombreFuncion{DameNodos} dos veces.
\\ La complejidad total sería: \Complejidad{n}+\Complejidad{n}+\Complejidad{n} = 3 * \Complejidad{n} = \Complejidad{n}
}

\Algoritmo{IDameNodos}{\In{p}{puntero(nodo)}, \In{actual}{nat}, \In{destino}{nat}}{Conj(nodo)}{
	\State $res$ $\gets$ \NombreFuncion{Vacío}() \ComplejidadDer{1}
	\If{p == NULL} \ComplejidadDer{1}
	\Else
		\If{actual == destino} \ComplejidadDer{1}
			\State \NombreFuncion{AgregarAtrás}($res$ , p) \ComplejidadDer{1}
		\Else
			\State \NombreFuncion{Union}(\NombreFuncion{DameNodos}(*(p).izq, actual + 1, destino), \NombreFuncion{DameNodos}(*(p).der, actual + 1, destino)) \ComplejidadDer{n}
		\EndIf
	\EndIf
}{\Complejidad{n}}{
}	


\Algoritmo{IRotar}{\Inout{p}{puntero(nodo)}}{}{
	\If{\NombreFuncion{FactorDesbalance}(p) $<$ 1} \ComplejidadDer{1}
		\If{\NombreFuncion{FactorDesbalance}(*(p).der) $>$ 1} \ComplejidadDer{1}
			\State $res$ $\gets$ \NombreFuncion{RotarDobleIzq}($p$) \ComplejidadDer{k}
		\Else 
			\State $res$ $\gets$ \NombreFuncion{RotarSimpleIzq}($p$) \ComplejidadDer{k}
		\EndIf
	\Else
		\If{\NombreFuncion{FactorDesbalance}(*(p).izq) $<$ 1} \ComplejidadDer{1}
			\State $res$ $\gets$\NombreFuncion{RotarDobleDer}($p$) \ComplejidadDer{k}
		\Else
			\State $res$ $\gets$ \NombreFuncion{RotarSimpleDer}($p$) \ComplejidadDer{k}
		\EndIf
	\EndIf
}{\Complejidad{k}}{
}

\Algoritmo{IRotarSimpleIzq}{\Inout{p}{puntero(nodo)}}{}{
	\State var r: puntero(nodo) $\gets$ p \ComplejidadDer{1}
	\State var r2: puntero(nodo) $\gets$ *(r).der \ComplejidadDer{1}
	\State var i: puntero(nodo) $\gets$ *(r).izq \ComplejidadDer{1}
	\State var i2: puntero(nodo) $\gets$ *(r2).izq \ComplejidadDer{1}
	\State var d2: puntero(nodo) $\gets$ *(r2).der \ComplejidadDer{1}
	\State var padre: puntero(nodo) $\gets$ *(r).padre \ComplejidadDer{1}
	\If{padre != NULL} \ComplejidadDer{1}
		\If{r == *(padre).izq} \ComplejidadDer{k}
			\State  *(padre).izq $\gets$ r2 \ComplejidadDer{1}
		\Else
			\State *(padre).der $\gets$ r2 \ComplejidadDer{1}
 		\EndIf
	\Else
	\EndIf
	\State *(r2).padre $\gets$ padre \ComplejidadDer{1}
	\State *(r2).izq $\gets$ r \ComplejidadDer{1}
	\State *(r).padre $\gets$ r2 \ComplejidadDer{1}
	\State *(r).der $\gets$ i2 \ComplejidadDer{1}
	\If{i2 != NULL} \ComplejidadDer{1}
		\State *(i2).padre $\gets$ r \ComplejidadDer{1}
	\Else
	\EndIf
	\State *(r).alt $\gets$ \NombreFuncion{Altura}(r) \ComplejidadDer{1}
	\State *(r2).alt $\gets$ \NombreFuncion{Altura}(r2) \ComplejidadDer{1}
 }{\Complejidad{k}}{
}	

\Algoritmo{IRotarSimpleDer}{\Inout{p}{puntero(nodo)}}{}{
	\State var r: puntero(nodo) $\gets$ p \ComplejidadDer{1}
	\State var r2: puntero(nodo) $\gets$ *(r).izq \ComplejidadDer{1}
	\State var d: puntero(nodo) $\gets$ *(r).der \ComplejidadDer{1}
	\State var i2: puntero(nodo) $\gets$  *(r2).izq \ComplejidadDer{1}
	\State var d2: puntero(nodo) $\gets$ *(r2).der \ComplejidadDer{1}
	\State var padre: puntero(nodo) $\gets$ *(r).padre \ComplejidadDer{1}
	\If{padre != NULL} \ComplejidadDer{1}
		\If{r == *(padre).izq} \ComplejidadDer{k}
			\State  *(padre).izq $\gets$ r2 \ComplejidadDer{1}
		\Else
			\State *(padre).der $\gets$ r2 \ComplejidadDer{1}
 		\EndIf
	\Else
	\EndIf	
	\State *(r2).padre $\gets$ padre \ComplejidadDer{1}
	\State *(r2).der $\gets$ r \ComplejidadDer{1}
	\State *(r).padre $\gets$ r2 \ComplejidadDer{1}
	\State *(r).izq $\gets$ d2 \ComplejidadDer{1}
	\If{d2 != NULL} \ComplejidadDer{1}
		\State *(d2).padre $\gets$ r \ComplejidadDer{1}
 	\Else
	\EndIf
	\State *(r).alt $\gets$ \NombreFuncion{Altura}(r) \ComplejidadDer{1}
	\State *(r2).alt $\gets$ \NombreFuncion{Altura}(r2) \ComplejidadDer{1}
}{\Complejidad{k}}{
}	

\Algoritmo{IRotarDobleIzq}{\Inout{p}{puntero(nodo)}}{}{
	\State \NombreFuncion{RotarSimpleDer}(*(p).der) \ComplejidadDer{k}
	\State \NombreFuncion{RotarSimpleIzq}(p) \ComplejidadDer{k}
}{\Complejidad{k}}{
}	

\Algoritmo{IRotarDobleDer}{\Inout{p}{puntero(nodo)}}{}{
	\State \NombreFuncion{RotarSimpleIzq}(*(p).izq) \ComplejidadDer{k}
	\State \NombreFuncion{RotarSimpleDer}(p) \ComplejidadDer{k}
}{\Complejidad{k}}{
}	

\Algoritmo{IAltura}{\In{p}{puntero(nodo)}}{nat}{
	\If{*(p).izq == NULL $\wedge$ *(p).der == NULL} \ComplejidadDer{1}
		\State $\res$ $\gets$ 1 \ComplejidadDer{1}
	\Else
		\If{*(p).izq != NULL $\wedge$ *(p).der == NULL} \ComplejidadDer{1}
			\State $\res$ $\gets$ *(*(p).izq).alt + 1 \ComplejidadDer{1}
		\Else
			\If{*(p).izq == NULL $\wedge$ *(p).der != NULL} \ComplejidadDer{1}
				\State $res$ $\gets$ *(*(p).der).alt + 1 \ComplejidadDer{1}
			\Else
				\State $res$ $\gets$ max(*(*(p).izq).alt, *(*(p).der).alt) + 1 \ComplejidadDer{1}
			\EndIf
		\EndIf
	\EndIf
}{\Complejidad{1}}{
}

\Algoritmo{IFactorDesbalance}{\In{p}{puntero(nodo)}}{nat}{
		\If{*(p).izq == NULL $\wedge$ *(p).der == NULL} \ComplejidadDer{1}
		\State $\res$ $\gets$ 0 \ComplejidadDer{1}
	\Else
		\If{*(p).izq != NULL $\wedge$ *(p).der == NULL} \ComplejidadDer{1}
			\State $\res$ $\gets$ *(*(p).izq).alt \ComplejidadDer{1}
		\Else
			\If{*(p).izq == NULL $\wedge$ *(p).der != NULL} \ComplejidadDer{1}
				\State $res$ $\gets$ - *(*(p).der).alt \ComplejidadDer{1}
			\Else
				\State $res$ $\gets$ *(*(p).izq).alt - *(*(p).der).alt \ComplejidadDer{1}
			\EndIf
		\EndIf
	\EndIf
}{\Complejidad{1}}{
}

\end{Algoritmos}




