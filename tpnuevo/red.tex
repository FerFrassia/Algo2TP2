\section{Red}

\subsection{Interfaz}

\begin{Interfaz}
  
  %\textbf{parámetros formales}\hangindent=2\parindent\\
  %\parbox{1.7cm}{\textbf{géneros}} \\
  %\parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    %\InterfazFuncion{Verifica?}{\In{c}{conj(tag)}, \In{r}{rest}}{$\alpha$}
    %{$res \igobs a$}
    %[$\Theta(copy(a))$]
    %[función de copia de $\alpha$'s]
  %}

  \textbf{se explica con}: \tadNombre{Red, Iterador Unidireccional($\alpha$)}.

  \textbf{géneros}: \TipoVariable{red, itConj(Compu)}.

  \Titulo{Operaciones básicas de Red}

  %\InterfazFuncion{NOMBRE}{INPUTS}{TIPO RES}%
  %[ACA VA EL PRE (SI LO HAY)]
  %{ACA VA EL POST}%
  %[$\Theta(COMPLEJIDAD)$]
  %[DESCRIPCION]

  \InterfazFuncion{Computadoras}{\In{r}{red}}{itConj(Compu)}
  %[ACA VA EL PRE (SI LO HUBIERA)]
  {$res \igobs$ crearIt(computadoras($r$))}
  [$\Complejidad{1}$]
  [Devuelve las computadoras de red.]
	
  \InterfazFuncion{Conectadas?}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{bool}
  [\{$c_1,c_2$\} $\subseteq$ computadoras($r$)]
  {$res \igobs$ conectadas?($r, c_1, c_2$)}
  [$\Complejidad{|c_1| + |c_2|}$]
  [Devuelve el valor de verdad indicado por la conexión o desconexión de dos computadoras.]

  \InterfazFuncion{InterfazUsada}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{interfaz}
  [\{$c_1, c_2$\} $\subseteq$ computadoras($r$) $\yluego$ conectadas?($r, c_1, c_2$)]
  {$res \igobs$ interfazUsada($r, c_1, c_2$)}
  [$\Complejidad{|c_1| + |c_2|}$]
  [Devuelve la interfaz que $c_1$ usa para conectarse con $c_2$]

  \InterfazFuncion{IniciarRed}{}{red}
  %[ACA VA EL PRE (SI LO HAY)]
  {$res \igobs$ iniciarRed()}
  [$\Complejidad{1}$]
  [Crea una red sin computadoras.]
	
  \InterfazFuncion{AgregarComputadora}{\Inout{r}{red}, \In{c}{compu}}{}
  [$r_0 \igobs r$ $\wedge$ $\neg$($c$ $\in$computadoras($r$))]
  {$r$ $\igobs$ agregarComputadora($r_0, c$)}
  [$\Complejidad{|c|}$]
  [Agrega una computadora a la red.]
  
   \InterfazFuncion{Conectar}{\Inout{r}{red}, \In{c_1}{compu}, \In{i_1}{interfaz}, \In{c_2}{compu}, \In{i_2}{interfaz}}{}
  [$r_0$ $\igobs$ r $\wedge$ \{$c_1,c_2$\} $\subseteq$ computadoras($r$) $\wedge$ ip($c_1$) $\neq$ ip($c_2$) $\yluego$ $\neg$ conectadas?($r, c_1, c_2$) $\wedge$ $\neg$ usaInterfaz?($r, c_1, i_1$) $\wedge$ $\neg$ usaInterfaz?($r, c_2, i_2$)]
  {$r$ $\igobs$ conectar($r, c_1, i_1, c_2, i_2$)}
  [$\Complejidad{|c_1| + |c_2|}$]
  [Conecta dos computadoras y les añade la interfaz correspondiente.]

  \InterfazFuncion{Vecinos}{\In{r}{red}, \In{c}{compu}}{conj(compu)}
  [$c$ $\in$ computadoras($r$)]
  {$res$ $\igobs$ vecinos(r, c)}
  []
  [Devuelve todas las computadoras que están conectadas directamente con c]

  \InterfazFuncion{UsaInterfaz?}{\In{r}{red}, \In{c}{compu}, \In{i}{interfaz}}{bool}
  [$c$ $\in$ computadoras($r$)]
  {$res$ $\igobs$ usaInterfaz?(r, c, i)}
  []
  [Verifica que una computadora use una interfaz]

  \InterfazFuncion{CaminosMinimos}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{itConj($\alpha$)}
  [\{$c_1,c_2$\} $\subseteq$ computadoras($r$)]
  {$res$ $\igobs$ crearItBi(caminosMinimos(r, $c_1$, $c_2$))}
  []
  [Devuelve todos los caminos minimos de conexiones entre una computadora y otra]

  \InterfazFuncion{HayCamino?}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{bool}
  [\{$c_1,c_2$\} $\subseteq$ computadoras($r$)]
  {$res$ $\igobs$ hayCamino?(r, $c_1$, $c_2$)}
  []
  [Verifica que haya un camino de conexiones entre una computadora y otra]
  
 \end{Interfaz}

\subsection{Auxiliares}
	%\Begin{Auxiliares}
  \Titulo{Operaciones auxiliares}
	
  \InterfazFuncion{CalcularCaminosMinimos}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{conj(lista)}
  [\{$c_1,c_2$\} $\subseteq$ computadoras($r$)]
  {$res$ $\igobs$ caminosMinimos(r, $c_1$, $c_2$)}
  [$\Complejidad{ALGO}$]
  [Devuelve los caminos minimos entre $c_1$ y $c_2$]
  
  \InterfazFuncion{CaminosImportantes}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}, \In{parcial}{lista}}{conj(lista)}
  [\{$c_1,c_2$\} $\subseteq$ computadoras($r$)]
  {$res$ $\igobs$ caminosMinimos(r, $c_1$, $c_2$)}
  [$\Complejidad{ALGO}$]
  [Devuelve los caminos suficientes (no todos) para calcular los caminos mínimos entre $c_1$ y $c_2$]

	%\End{Auxiliares}
\subsection{Representacion}

\begin{Representacion}

\bigskip
\begin{Estructura}{red}[e\_red]
	\begin{Tupla}[e\_red]
		\tupTupItem{directasEInterfaces}{\TipoVariable{diccString}$($\ignorespaces
			% NOTA:tupTupItem es un engendro que agregue para este caso, NO USAR EN OTRO LADO, USAR tupItem EN SU LUGAR.
			\emph{compu}: \TipoVariable{string},
			tupla(
			\emph{directas}: \TipoVariable{diccString}$($\ignorespaces
				\emph{compu}: \TipoVariable{string}, \ignorespaces
				\emph{interfaz}: \TipoVariable{nat}\ignorespaces
			$)$,
			\emph{compusDirectas}: \TipoVariable{conj(compu)}
			$) )$} \\
			\tupTupItem{deOrigenADestino}{\TipoVariable{diccString}$($\ignorespaces
			\emph{compu}: \TipoVariable{string},
			\emph{indirectas}: \TipoVariable{diccString}
			$($\ignorespaces
				\emph{compu}: \TipoVariable{string}, \ignorespaces
				\emph{caminosMinimos}: \TipoVariable{conj(lista(compu))}\ignorespaces
			$) )$} \\
			\tupItem{computadoras}{\TipoVariable{conj(compu)}}
	\end{Tupla}
	
\end{Estructura}

\subsection{InvRep y Abs}

\begin{enumerate}
	\item{Las claves de $directasEInterfaces$ son las mismas que las de $deOrigenADestino$ y también que el conjunto formado por las ip de $computadoras$.}
		\item{}
\end{enumerate}

\Rep[e\_mapa][m]{
	\\m.estaciones = claves(m.uniones) $\wedge$ \hfill 1.
	\\m.\#sendas = \#sendasPorDos(m.estaciones, m.uniones) / 2 $\wedge$ m.\#sendas $\leq$ long(m.sendas) $\yluego$ \hfill 2. 5.
	\\($\forall$ e1, e2: string)(e1 $\in$ claves(m.uniones) $\yluego$ e2 
	$\in$ claves(obtener(e1, m.uniones)) $\impluego$\\ 
	e2 $\in$ claves(m.uniones) $\yluego$ e1 $\in$ claves(obtener(e2, m.uniones)) $\yluego$ 
	\\ obtener(e2, obtener(e1, m.uniones)) = obtener(e1, obtener(e2, m.uniones)) $\wedge$ \hfill 3. 4.	
	\\ obtener(e2, obtener(e1, m.uniones)) $<$ m.\#sendas) $\wedge$
	\\($\forall$ e1, e2, e3, e4: string)((e1 $\in$ claves(m.uniones) $\yluego$
	e2 $\in$ claves(obtener(e1, m.uniones)) $\wedge$\\ 
	e3 $\in$ claves(m.uniones) $\yluego$ e4 $\in$ claves(obtener(e3, m.uniones))) $\impluego$
	\\ (obtener(e2, obtener(e1, m.uniones)) $=$ obtener(e4, obtener(e3, m.uniones)) $\ssi$
	\\ (e1 = e3 $\wedge$ e2 = e4) $\vee$ (e1 = e4 $\wedge$ e2 = e3)))) \hfill 3.
}

\vspace{2em}
	
\tadOperacion{\#sendasPorDos}{conj($\alpha$)\ c, dicc($\alpha$, dicc($\alpha$, $\beta$))\ d}
														{nat}{c $\subset$ claves(d)}

\vspace{1em}

\tadAxioma{\#sendasPorDos(c, d)}{\IF $\emptyset$?(c) THEN 0
												ELSE \#claves(obtener(dameUno(c),d)) $+$ \#sendasPorDos(sinUno(c), d)
												FI}

\vspace{2em}

\Abs[e\_mapa]{mapa}[m]{p}{
	\\ m.estaciones = estaciones(p) $\yluego$
	\\ ($\forall$ e1, e2: string)((e1 $\in$ estaciones(p) $\wedge$ e2 $\in$ estaciones(p)) $\impluego$
	\\ (conectadas?(e1, e2, p) $\ssi$
	\\   e1 $\in$ claves(m.uniones) $\wedge$ e2 $\in$ claves(obtener(e2, m.uniones)))) $\yluego$
	\\ ($\forall$ e1, e2: string)((e1 $\in$ estaciones(p) $\wedge$ e2 $\in$ estaciones(p)) $\yluego$
	\\ conectadas?(e1, e2, p) $\impluego$ 
	\\ (restriccion(e1, e2, p) = m.sendas[obtener(e2, obtener(e1, m.uniones))] $\wedge$
	   nroConexion(e1, e2, m) = obtener(e2, obtener(e1, m.uniones))) $\wedge$
	   long(restricciones(p)) = m.\#sendas $\yluego$
		 ($\forall$ n:nat) (n < m.\#sendas $\impluego$ m.sendas[n] = ElemDeSecu(restricciones(p), n)))
}

\end{Representacion}

\subsection{Algoritmos}

\begin{Algoritmos}
	
	%Algoritmos / Inputs / TSalida / Codigo / Complejidad Final / Justificacion
	\begin{Algoritmo}{iComputadoras}{\In{r}{red}}{itConj(Compu)}
	{
		\State $res$ $\gets$ CrearIt($r.computadoras$) \ComplejidadDer{1}
	} 
	{$\Complejidad{1}$}{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iConectadas?}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{bool}
	{
		\State $res$ $\gets$ Definido?(Significado($r.directasEInterfaces$, $c_1.ip$)$.directas$, $c_2.ip$) \ComplejidadDer{|c_1| + |c_2|}
	}
	{$\Complejidad{|c_1| + |c_2|}$}{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iInterfazUsada}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{interfaz}
	{
		\State $res$ $\gets$ Significado(Significado($r.directasEInterfaces$, $c_1.ip$)$.directas$, $c_2.ip$)\ComplejidadDer{|c_1| + |c_2|}
	}
	{$\Complejidad{|c_1| + |c_2|}$}{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iIniciarRed}{}{red}
	{
		\State $res$ $\gets$ tupla($directasEInterfaces$: Vacío(), $deOrigenADestino$: Vacío(), $computadoras$: Vacío()) \ComplejidadDer{1 + 1 + 1}
	}
	{$\Complejidad{1}$}
	{$\Complejidad{1}  + \Complejidad{1} + \Complejidad{1} = \newline
	  3 * \Complejidad{1} = \Complejidad{1}$}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iAgregarComputadora}{\Inout{r}{red}, \In{c}{compu}}{}
	{
		\State Agregar($r.computadoras$, $c$) \ComplejidadDer{1}
		\State Definir($r.directasEInterfaces$, $c.ip$, tupla(Vacío(), Vacio())) \ComplejidadDer{|c|}
		\State Definir($r.deOrigenADestino$, $c.ip$, Vacío()) \ComplejidadDer{|c|}
	}
	{$\Complejidad{|c|}$}
	{$\Complejidad{1} + \Complejidad{|c|} + \Complejidad{|c|} = \newline
	2 * \Complejidad{|c|} = \Complejidad{|c|}$}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iConectar}{\Inout{r}{red}, \In{c_1}{compu}, \In{i_1}{interfaz}, \In{c_2}{compu}, \In{i_2}{interfaz}}{}
	{
		%Armo la primera componente de e_red
		
		\State var $tupSig1$:tupla $\gets$ Significado($r.directasEInterfaces$, $c_1.ip$)
		%Guardo la interfaz usada por c_1
		\State Definir($tupSig1.directas$, $c_2.ip$, $i_1$) \ComplejidadDer{|c_1| + |c_2| + 1}
		%Agrego c_2 a las compusDirectas de c_1
		\State Agregar($tupSig1.compusDirectas$, $c_2$) \ComplejidadDer{1}

		\State var $tupSig2$:tupla $\gets$ Significado($r.directasEInterfaces$, $c_2.ip$)
		%Guardo la interfaz usada por c_2		
		\State Definir($tupSig2.directas$, $c_1.ip$, $i_2$) \ComplejidadDer{|c_1| + |c_2| + 1}
		%Agrego c_2 a las compusDirectas de c_1
		\State Agregar($tupSig2.compusDirectas$, $c_1$) \ComplejidadDer{1}
		

		%Armo la segunda componente de e_red
				
		%Guardo los caminos minimos de c_1 a c_2
		\State Definir(Significado($r.deOrigenADestino$, $c_1.ip$), $c_2.ip$, CalcularCaminosMinimos($r, c_1, c_2$)) \ComplejidadDer{1}
		%Guardo los caminos minimos de c_2 a c_1
		\State Definir(Significado($r.deOrigenADestino$, $c_2.ip$), $c_1.ip$, CalcularCaminosMinimos($r, c_2, c_1$)) \ComplejidadDer{1}		
	}
	{$\Complejidad{|e_1| + |e_2|}$}
	{$\Complejidad{|e_1| + |e_2|} + \Complejidad{|e_1| + |e_2|} + \Complejidad{1} + \Complejidad{1} = \newline
	  2 * \Complejidad{1} + 2 * \Complejidad{|e_1| + |e_2|} = \newline
		2 * \Complejidad{|e_1| + |e_2|} = \Complejidad{|e_1| + |e_2|}$}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iVecinos}{\In{r}{red}, \In{c}{compu}}{conj(compu)}
	{
		\State $res$ $\gets$ Significado($r.directasEInterfaces$, $c.ip$)$.compusDirectas$
	}
	{}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iUsaInterfaz}{\In{r}{red}, \In{c}{compu}, \In{i}{interfaz}}{bool}
	{
		\State var $tupVecinos$:tupla $\gets$ Significado($r.directasEInterfaces$, $c.ip$) \ComplejidadDer{1}
		\State var $itcompusDirectas$:itConj(compu) $\gets$ CrearIt($tupVecinos.compusDirectas$) \ComplejidadDer{1}
		\State $res$:bool $\gets$ $false$ \ComplejidadDer{1}
		\While{HaySiguiente($itcompusDirectas$) AND $¬res$} \ComplejidadDer{1}
		\If {Significado($tupVecinos.directas$, Siguiente($itcompusDirectas$)$.ip$) $==$ $i$} \ComplejidadDer{1}
			\State $res$ $\gets$ $true$  \ComplejidadDer{1}
		\EndIf
		\State Avanzar($it$) \ComplejidadDer{1}
		\EndWhile
	}
	{}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iCaminosMinimos}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{itConj($\alpha$)}
	{
		\State $res$ $\gets$ CrearIt(Significado(Significado($r.deOrigenADestino$, $c_1.ip$), $c_2.ip$))	\ComplejidadDer{1}
	}
	{}
	{}
	\end{Algoritmo}

	\begin{Algoritmo}{iHayCamino}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{bool}
	{
		\State var $conjCaminosMinimos$ $\gets$ CaminosMinimos($r$, $c_1$, $c_2$) \ComplejidadDer{1}
		\State $res$ $\gets$ EsVacio?($conjCaminosMinimos$) \ComplejidadDer{1}
	}
	{}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iCalcularCaminosMinimos}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{conj(lista)}
	{
		\State $res$ $\gets$ Vacio() \ComplejidadDer{1}
		\State var $conjCaminosImportantes$:conj(lista) $=$ Vacio() \ComplejidadDer{1}
		\State var $pacial$:lista $\gets$ Vacia() \ComplejidadDer{1}
		\State AgregarAtras($parcial$, $c_1$) \ComplejidadDer{1}
		\State $conjCaminosImportantes$ $\gets$ \NombreFuncion{CaminosImportantes}($r$, $c_1$, $c_2$, $parcial$) \ComplejidadDer{1}
		
		%Ahora que tengo los caminos calculo los mínimos
		\State var $itCaminosImportantes$:itConj $\gets$ CrearIt($conjCaminosImportantes$) \ComplejidadDer{1}
		\While {HaySiguiente?($itCaminosImportantes$)} \ComplejidadDer{1}
			\If {EsVacio?($res$) $\vee$ Longitud(DameUno($res$)) $=$ Longitud(Siguiente($itCaminosImportantes$))} \ComplejidadDer{1}
				\State Agregar($res$, Siguiente($itCaminosImportantes$)) \ComplejidadDer{1}
			\Else
				\If {Longitud(DameUno($res$)) $<$ Longitud(Siguiente($itCaminosImportantes$))} \ComplejidadDer{1}
					\State $res$ $\gets$ Vacio() \ComplejidadDer{1}
					\State Agregar($res$, Siguiente($itCaminosImportantes$)) \ComplejidadDer{1}
				\EndIf
			\EndIf
		\EndWhile	
	}
	{}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iCaminosImportantes}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}, \In{pacial}{lista(compu)}}{conj(lista)}
	{
		\State $res$ $\gets$ Vacio() \ComplejidadDer{1}
		
		\If {Pertenece?(Vecinos($r$, $c_1$), $c_2$)} \ComplejidadDer{1}
			\State AgregarAtras($pacial$, $c_2$) \ComplejidadDer{1}		
			\State Agregar($res$, $parcial$) \ComplejidadDer{1}
		\Else
			\State var $itVecinos$:itConj $\gets$ CrearIt(Vecinos($r$, $c_1$)) \ComplejidadDer{1}
			\While{HaySiguiente?($itVecinos$)} \ComplejidadDer{1}
				\If {$¬$Pertenece?($parcial$, Siguiente($itVecinos$))} \ComplejidadDer{1}
					\State var $auxParcial$:lista $\gets$ parcial \ComplejidadDer{1}
					\State AgregarAtras($auxParcial$, Siguiente($itVecinos$)) \ComplejidadDer{1}
					\State Unir($res$, CaminosImportantes($r$, Siguiente($itVecinos$), $c_2$, $auxParcial$)) \ComplejidadDer{1}
				\EndIf	
				\State Avanzar($itVecinos$) \ComplejidadDer{1}
			\EndWhile			
		\EndIf
	}
	{}
	{}
	\end{Algoritmo}
		
	%\begin{Algoritmo}{iNroConexion}{\In{e1}{estación}, \In{e2}{estación}, \In{m}{mapa}}{nat}
	%{
	%	\State $res$ $\gets$ Significado(Significado($m.uniones$, $e1$), $e2$) \ComplejidadDer{|e_1| + |e_2|}
	%}
	%{$\Complejidad{|e_1| + |e_2|}$}{}
	%\end{Algoritmo}
	%
	%\begin{Algoritmo}{iEvaluarSendas}{\In{c}{conj(tag)}, \In{m}{mapa}}{arreglo\_dimesionable de bool}
	%{
	%	\State $res$ $\gets$ arreglo[$m.\#sendas$] de bool \ComplejidadDer{1}
	%	\State var $i$: nat $\gets$ 0 \ComplejidadDer{1}
	%	\While{$i < m.\#sendas$} \ComplejidadDer{1}
	%		\State $res[i]$ $\gets$ Verifica?($c$, $m.sendas[i]$) \ComplejidadDer{R}
	%		\State $i++$ \ComplejidadDer{1}
	%	\EndWhile
	%}
	%{$\Complejidad{S * R}$}
	%{$\Complejidad{1} + \Complejidad{1} + \sum_{i = 1}^{S} (\Complejidad{R} + \Complejidad{1}) = \newline
	%	2 * \Complejidad{1} + S * (\Complejidad{R} + \Complejidad{1}) = \newline
	%	2 * \Complejidad{1} + S * \Complejidad{1} + S * \Complejidad{R} = \newline
	%	\Complejidad{S} + S * \Complejidad{R} = \newline
	%	\Complejidad{S + S * R} = \Complejidad{S * R}
	%$\newline
	%$S$ es |m.sendas| y $R$ es la longitud de la restriccion mas grande}
	%\end{Algoritmo}
	
	%\begin{Algoritmo}{iRestricciones}{\In{m}{mapa}}{arreglo\_dimesionable de restriccion}
	%{
	%	\State $res$ $\gets$ arreglo\_dimensionable[$m.\#sendas$] \ComplejidadDer{1}
	%	\State var $i$: nat $\gets$ 0 \ComplejidadDer{1}
	%	\While{$i < m.\#sendas$} \ComplejidadDer{1}
	%		\State $res[i]$ $\gets$ $m.sendas[i]$ \ComplejidadDer{1}
	%		\State $i++$ \ComplejidadDer{1}
	%	\EndWhile
	%}
	%{$\Complejidad{S}$}
	%{$\Complejidad{1} + \Complejidad{1} + \sum_{i = 1}^{S} (\Complejidad{1} + \Complejidad{1}) = \newline
	%	2 * \Complejidad{1} + S * 2 *\Complejidad{1} = \newline
	%	2 * \Complejidad{1} + 2 * \Complejidad{S} = \newline
	%	2 * \Complejidad{S} = \Complejidad{S}
	% $}
	%\end{Algoritmo}
	%
\end{Algoritmos}