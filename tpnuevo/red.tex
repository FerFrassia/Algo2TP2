\section{Red}

\subsection{Interfaz}

\begin{Interfaz}
  
  %\textbf{parámetros formales}\hangindent=2\parindent\\
  %\parbox{1.7cm}{\textbf{géneros}} \\
  %\parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    %\InterfazFuncion{Verifica?}{\In{c}{conj(tag)}, \In{r}{rest}}{$\alpha$}
    %{$res \igobs a$}
    %[$\Theta(copy(a))$]
    %[función de copia de $\alpha$'s]
  %}

  \textbf{se explica con}: \tadNombre{Red, Iterador Unidireccional($\alpha$)}.

  \textbf{géneros}: \TipoVariable{red, itConj(Compu)}.

  \Titulo{Operaciones básicas de Red}

  %\InterfazFuncion{NOMBRE}{INPUTS}{TIPO RES}%
  %[ACA VA EL PRE (SI LO HAY)]
  %{ACA VA EL POST}%
  %[$\Theta(COMPLEJIDAD)$]
  %[DESCRIPCION]

  \InterfazFuncion{Computadoras}{\In{r}{red}}{itConj(Compu)}
  %[ACA VA EL PRE (SI LO HUBIERA)]
  {$res \igobs$ crearIt(computadoras($r$))}
  [$\Complejidad{1}$]
  [Devuelve las computadoras de red.]
	
  \InterfazFuncion{Conectadas?}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{bool}
  [\{$c_1,c_2$\} $\subseteq$ computadoras($r$)]
  {$res \igobs$ conectadas?($r, c_1, c_2$)}
  [$\Complejidad{|c_1| + |c_2|}$]
  [Devuelve el valor de verdad indicado por la conexión o desconexión de dos computadoras.]

  \InterfazFuncion{InterfazUsada}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{interfaz}
  [\{$c_1, c_2$\} $\subseteq$ computadoras($r$) $\yluego$ conectadas?($r, c_1, c_2$)]
  {$res \igobs$ interfazUsada($r, c_1, c_2$)}
  [$\Complejidad{|c_1| + |c_2|}$]
  [Devuelve la interfaz que $c_1$ usa para conectarse con $c_2$]

  \InterfazFuncion{IniciarRed}{}{red}
  %[ACA VA EL PRE (SI LO HAY)]
  {$res \igobs$ iniciarRed()}
  [$\Complejidad{1}$]
  [Crea una red sin computadoras.]
	
  \InterfazFuncion{AgregarComputadora}{\Inout{r}{red}, \In{c}{compu}}{}
  [$r_0 \igobs r$ $\wedge$ $\neg$($c$ $\in$computadoras($r$))]
  {$r$ $\igobs$ agregarComputadora($r_0, c$)}
  [$\Complejidad{|c|}$]
  [Agrega una computadora a la red.]
  
   \InterfazFuncion{Conectar}{\Inout{r}{red}, \In{c_1}{compu}, \In{i_1}{interfaz}, \In{c_2}{compu}, \In{i_2}{interfaz}}{}
  [$r_0$ $\igobs$ r $\wedge$ \{$c_1,c_2$\} $\subseteq$ computadoras($r$) $\wedge$ ip($c_1$) $\neq$ ip($c_2$) $\yluego$ $\neg$ conectadas?($r, c_1, c_2$) $\wedge$ $\neg$ usaInterfaz?($r, c_1, i_1$) $\wedge$ $\neg$ usaInterfaz?($r, c_2, i_2$)]
  {$r$ $\igobs$ conectar($r, c_1, i_1, c_2, i_2$)}
  [$\Complejidad{|c_1| + |c_2|}$]
  [Conecta dos computadoras y les añade la interfaz correspondiente.]

  \InterfazFuncion{Vecinos}{\In{r}{red}, \In{c}{compu}}{conj(compu)}
  [$c$ $\in$ computadoras($r$)]
  {$res$ $\igobs$ vecinos(r, c)}
  []
  [Devuelve todas las computadoras que están conectadas directamente con c]

  \InterfazFuncion{UsaInterfaz?}{\In{r}{red}, \In{c}{compu}, \In{i}{interfaz}}{bool}
  [$c$ $\in$ computadoras($r$)]
  {$res$ $\igobs$ usaInterfaz?(r, c, i)}
  []
  [Verifica que una computadora use una interfaz]

  \InterfazFuncion{CaminosMinimos}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{itConj($\alpha$)}
  [\{$c_1,c_2$\} $\subseteq$ computadoras($r$)]
  {$res$ $\igobs$ crearItBi(caminosMinimos(r, $c_1$, $c_2$))}
  []
  [Devuelve todos los caminos minimos de conexiones entre una computadora y otra]

  \InterfazFuncion{HayCamino?}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{bool}
  [\{$c_1,c_2$\} $\subseteq$ computadoras($r$)]
  {$res$ $\igobs$ hayCamino?(r, $c_1$, $c_2$)}
  []
  [Verifica que haya un camino de conexiones entre una computadora y otra]
  
 \end{Interfaz}

\subsection{Auxiliares}
	%\Begin{Auxiliares}
  \Titulo{Operaciones auxiliares}
	
  \InterfazFuncion{CalcularCaminosMinimos}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{conj(lista)}
  [\{$c_1,c_2$\} $\subseteq$ computadoras($r$)]
  {$res$ $\igobs$ caminosMinimos(r, $c_1$, $c_2$)}
  [$\Complejidad{ALGO}$]
  [Devuelve los caminos minimos entre $c_1$ y $c_2$]
  
  \InterfazFuncion{CaminosImportantes}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}, \In{parcial}{lista}}{conj(lista)}
  [\{$c_1,c_2$\} $\subseteq$ computadoras($r$)]
  {$res$ $\igobs$ caminosMinimos(r, $c_1$, $c_2$)}
  [$\Complejidad{ALGO}$]
  [Devuelve los caminos suficientes (no todos) para calcular los caminos mínimos entre $c_1$ y $c_2$]

	%\End{Auxiliares}
\subsection{Representacion}

\begin{Representacion}

\bigskip
\begin{Estructura}{red}[e\_red]
	\begin{Tupla}[e\_red]
		\tupTupItem{directasEInterfaces}{\TipoVariable{diccString}$($\ignorespaces
			% NOTA:tupTupItem es un engendro que agregue para este caso, NO USAR EN OTRO LADO, USAR tupItem EN SU LUGAR.
			\emph{compu}: \TipoVariable{string},
			tupla(
			\emph{directas}: \TipoVariable{diccString}$($\ignorespaces
				\emph{compu}: \TipoVariable{string}, \ignorespaces
				\emph{interfaz}: \TipoVariable{nat}\ignorespaces
			$)$,
			\emph{compusDirectas}: \TipoVariable{conj(compu)}
			$) )$} \\
			\tupTupItem{deOrigenADestino}{\TipoVariable{diccString}$($\ignorespaces
			\emph{compu}: \TipoVariable{string},
			\emph{destinos}: \TipoVariable{diccString}
			$($\ignorespaces
				\emph{compu}: \TipoVariable{string}, \ignorespaces
				\emph{caminosMinimos}: \TipoVariable{conj(lista(compu))}\ignorespaces
			$) )$} \\
			\tupItem{computadoras}{\TipoVariable{conj(compu)}}
	\end{Tupla}
	
\end{Estructura}

\subsection{InvRep y Abs}

\begin{enumerate}
	\item{claves($directasEInterfaces$) es igual a claves($deOrigenADestino$), al conjunto formado por las ip de $computadoras$ y también a claves($directas$).}
	\item{Si def?(c, $directas$) de alguna clave de $directasEInterfaces$ entonces c pertenece al conjunto formado por las ip de $computadoras$.}
	\item{Para todo c, si def?(c, $directasEInterfaces$), entonces $\neg$def?(c, obtener(c, $directasEInterfaces$).$directas$).}
	\item{Para todo $c_1$ def?($c_1$, $directasEInterfaces$) $\yluego$ def?($c_2$, Obtener($c_1$, $directasEInterfaces$).$directas$) $\Leftrightarrow$ def?($c_2$, $directasEInterfaces$) $\yluego$ def?($c_1$, Obtener($c_2$, $directasEInterfaces$).$directas$).}
	\item{Los significados de $directas$ son únicos.}	
	\item{Si def?(c, $destinos$) de alguna clave de $deOrigenADestino$ entonces c pertenece al conjunto formado por las ip de $computadoras$.}
	\item{Para todo c, si def?(c, $deOrigenADestino$), entonces $\neg$def?(c, obtener(c, $deOrigenADestino$)).}
	\item{Para todo c, si def?(c, $deOrigenADestino$), entonces Claves(Obtener(c, $deOrigenADestino$)) es igual al conjunto formado por las ip de $computadoras$ menos la ip de c.}
	\item{Si c pertenece a alguna lista de $significados$ de $destinos$ para cualquier clave, entonces c pertenece a $computadoras$.}
	
	
\end{enumerate}

\Rep[red][r]{
\begin{enumerate}
	\item{claves(e.$directasEInterfaces$) = claves(e.$deOrigenADestino$) = conjips(e.$computadoras$) $\wedge$ (($\forall$ $c$:ip) (def?($c$, e.$directasEInterfaces$) $\impluego$ Claves(Obtener($c$, e.$directasEInterfaces$).$directas$) = conjips(e.$computadoras$))) $\wedge$ (($\forall$ $c$:ip) (def?($c$, e.$deOrigenADestino$) $\impluego$ Claves(Obtener($c$, e.$deOrigenADestino$)) = conjips(e.$computadoras$))) $\yluego$}
	\item{($\forall$ $c_1$, $c_2$:ip) (def?($c_1$, e.$directasEInterfaces$) $\yluego$ def?($c_2$, Obtener($c_1$, e.$directasEInterfaces$).$directas$) $\impluego$ $c_2$ $\in$ conjips(e.$computadoras$)) $\yluego$}
	\item{($\forall$ $c$:ip) (def?($c$, e.$directasEInterfaces$) $\impluego$ $\neg$def?($c$, Obtener($c$, e.$directasEInterfaces$).$directas$)) $\yluego$}
	\item{($\forall$ $c_1$, $c_2$:ip) (def?($c_1$, e.$directasEInterfaces$) $\yluego$ def?($c_2$, Obtener($c_1$, e.$directasEInterfaces$).$directas$) $\Leftrightarrow$ def?($c_2$, e.$directasEInterfaces$) $\yluego$ def?($c_1$, Obtener($c_2$, e.$directasEInterfaces$).$directas$)) $\yluego$}
	\item{($\forall$ $c_1$, $c_2$, $c_3$:ip) ($c_2$ $\neq$ $c_3$ $\wedge$ def?($c_1$, e.$directasEInterfaces$) $\yluego$ def?($c_2$, Obtener($c_1$, e.$directasEInterfaces$).$directas$) $\wedge$ def?($c_3$, Obtener($c_1$, e.$directasEInterfaces$).$directas$) $\impluego$ obtener($c_2$, Obtener($c_1$, e.$directasEInterfaces$).$directas$) $\neq$ obtener($c_3$, Obtener($c_1$, e.$directasEInterfaces$).$directas$)) $\yluego$}
	\item{($\forall$ $c$:ip) (def?($c$, e.$deOrigenADestino$) $\impluego$ Claves(Obtener($c$, e.$deOrigenADestino$)) $\subseteq$ conjips(e.$computadoras$)) $\yluego$}
	\item{($\forall$ $c$:ip)(def?($c$, e.$deOrigenADestino$) $\rightarrow$ $\neg$def?($c$, Obtener($c$, e.$deOrigenADestino$)) $\yluego$}
	\item{($\forall$ $c_1, c_2, c_3$:compu) (def?($c_1.ip$, e.$deOrigenADestino$) $\yluego$ def?($c_2.ip$, Obtener($c_1$, e.$deOrigenADestino$)) $\yluego$ Pertenece?($c_3$, Obtener($c_2.ip$, Obtener($c_1$, e.$deOrigenADestino$)) $\impluego$ $c_3$ $\in$ e.$computadoras$ )}
\end{enumerate}
}

\vspace{2em}

\Abs[e\_red]{red}[e]{r}{
	\\computadoras(r) = e.computadoras $\yluego$ 
	\\($\forall$ $c_1, c_2$:compu) ($c_1$ $\in$ computadoras(r) $\wedge$ $c_2$ $\in$ computadoras(r) $\impluego$ (Def?($c_1$, e.$directasEInterfaces$) $\yluego$ Def?($c_2$, Obtener($c_1$, e.$directasEInterfaces$).$directas$ = conectadas?(r, $c_1$, $c_2$))) $\yluego$
	\\($\forall$ $c_1, c_2$:compu) (conectadas?(r, $c_1$, $c_2$) $\impluego$ (Obtener($c_2$, Obtener($c_1$, e.$directasEInterfaces$).$directas$) = interfazUsada(r, $c_1$, $c_2$)))
}

\end{Representacion}

\subsection{Algoritmos}

\begin{Algoritmos}
	
	%Algoritmos / Inputs / TSalida / Codigo / Complejidad Final / Justificacion
	\begin{Algoritmo}{iComputadoras}{\In{r}{red}}{itConj(Compu)}
	{
		\State $res$ $\gets$ CrearIt($r.computadoras$) \ComplejidadDer{1}
	} 
	{$\Complejidad{1}$}{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iConectadas?}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{bool}
	{
		\State $res$ $\gets$ Def?(Obtener($r.directasEInterfaces$, $c_1.ip$)$.directas$, $c_2.ip$) \ComplejidadDer{|c_2.ip| + |c_1.ip|}
	}
	{$\Complejidad{|c_1.ip| + |c_2.ip|}$}{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iInterfazUsada}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{interfaz}
	{
		\State $res$ $\gets$ Obtener(Obtener($r.directasEInterfaces$, $c_1.ip$)$.directas$, $c_2.ip$)\ComplejidadDer{|c_1.ip| + |c_2.ip|}
	}
	{$\Complejidad{|c_1.ip| + |c_2.ip|}$}{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iIniciarRed}{}{red}
	{
		\State $res$ $\gets$ tupla($directasEInterfaces$: Vacío(), $deOrigenADestino$: Vacío(), $computadoras$: Vacío()) \ComplejidadDer{1 + 1 + 1}
	}
	{$\Complejidad{1}$}
	{$\Complejidad{1}  + \Complejidad{1} + \Complejidad{1} = \newline
	  3 * \Complejidad{1} = \Complejidad{1}$}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iAgregarComputadora}{\Inout{r}{red}, \In{c}{compu}}{}
	{
		\State Definir($r.directasEInterfaces$, $c.ip$, tupla(Vacío(), Vacio())) \ComplejidadDer{|c.ip|}
		
		\State var $itComputadoras$:itConj($\alpha$) $\gets$ CrearIt($r.computadoras$) \ComplejidadDer{1}
		
		\While {HaySiguiente?($itComputadoras$)} \ComplejidadDer{1}
			\State Definir(Obtener($r.deOrigenADestino$, Siguiente($itComputadoras$).$ip$), $c.ip$, Vacío()) \ComplejidadDer{|Siguiente($itComputadoras$).$ip$| + |c.ip|}
			\State Avanzar($itComputadoras$) \ComplejidadDer{1}
		\EndWhile
		
		\State var $dicNuevaCompu$:dicString($\alpha$) $\gets$ Vacio() \ComplejidadDer{1}
		
		\While {HayAnterior?($itComputadoras$)} \ComplejidadDer{1}
			\State Definir($dicNuevaCompu$, Anterior($itComputadoras$).$ip$, Vacío()) \ComplejidadDer{1}
			\State Retroceder($itComputadoras$) \ComplejidadDer{1}
		\EndWhile		
		
		\State Definir($r.deOrigenADestino$, $c.ip$, $dicNuevaCompu$) \ComplejidadDer{1}
		
		\State Agregar($r.computadoras$, $c$) \ComplejidadDer{1}
	}
	{$\Complejidad{|c|}$}
	{$\Complejidad{1} + \Complejidad{|c|} + \Complejidad{|c|} = \newline
	2 * \Complejidad{|c|} = \Complejidad{|c|}$}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iConectar}{\Inout{r}{red}, \In{c_1}{compu}, \In{i_1}{interfaz}, \In{c_2}{compu}, \In{i_2}{interfaz}}{}
	{
		%Armo la primera componente de e_red
		
		\State var $tupSig1$:tupla $\gets$ Obtener($r.directasEInterfaces$, $c_1.ip$)
		%Guardo la interfaz usada por c_1
		\State Definir($tupSig1.directas$, $c_2.ip$, $i_1$) \ComplejidadDer{|c_1| + |c_2| + 1}
		%Agrego c_2 a las compusDirectas de c_1
		\State Agregar($tupSig1.compusDirectas$, $c_2$) \ComplejidadDer{1}

		\State var $tupSig2$:tupla $\gets$ Obtener($r.directasEInterfaces$, $c_2.ip$)
		%Guardo la interfaz usada por c_2		
		\State Definir($tupSig2.directas$, $c_1.ip$, $i_2$) \ComplejidadDer{|c_1| + |c_2| + 1}
		%Agrego c_2 a las compusDirectas de c_1
		\State Agregar($tupSig2.compusDirectas$, $c_1$) \ComplejidadDer{1}
		

		%Armo la segunda componente de e_red
				
		%Guardo los caminos minimos de c_1 a c_2
		%\State Definir(Obtener($r.deOrigenADestino$, $c_1.ip$), $c_2.ip$, CalcularCaminosMinimos($r, c_1, c_2$)) \ComplejidadDer{1}
		%Guardo los caminos minimos de c_2 a c_1
		%\State Definir(Obtener($r.deOrigenADestino$, $c_2.ip$), $c_1.ip$, CalcularCaminosMinimos($r, c_2, c_1$)) \ComplejidadDer{1}
		
		
		\State var $itOrigenes$:itConj($\alpha$) $\gets$ CrearIt($r.computadoras$) \ComplejidadDer{1}
		\While {HaySiguiente?($itOrigenes$)} \ComplejidadDer{1}
			\State var $dicCompu$:dicString($\alpha$) $\gets$ Obtener($r.deOrigenADestino$, Siguiente($itOrigenes$).$ip$) \ComplejidadDer{1}
			\State var $itDestinos$:itConj($\alpha$) $\gets$ CrearIt($r.computadoras$) \ComplejidadDer{1}
			\While {HaySiguiente?($itDestinos$)} \ComplejidadDer{1}
				\If {Siguiente($itOrigenes$) $<>$ Siguiente($itDestinos$))} \ComplejidadDer{1}
					\State Definir($dicCompu$, Siguiente($itDestinos$).$ip$), CalcularCaminosMinimos($r$, Siguiente($itOrigenes$), Siguiente($itDestinos$))) \ComplejidadDer{1} 
				\EndIf
				\State Avanzar($itDestinos$) \ComplejidadDer{1}
			\EndWhile
			\State Avanzar($itOrigenes$) \ComplejidadDer{1}
		\EndWhile		
		
		
		
		
				
	}
	{$\Complejidad{|e_1| + |e_2|}$}
	{$\Complejidad{|e_1| + |e_2|} + \Complejidad{|e_1| + |e_2|} + \Complejidad{1} + \Complejidad{1} = \newline
	  2 * \Complejidad{1} + 2 * \Complejidad{|e_1| + |e_2|} = \newline
		2 * \Complejidad{|e_1| + |e_2|} = \Complejidad{|e_1| + |e_2|}$}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iVecinos}{\In{r}{red}, \In{c}{compu}}{conj(compu)}
	{
		\State $res$ $\gets$ Obtener($r.directasEInterfaces$, $c.ip$)$.compusDirectas$
	}
	{}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iUsaInterfaz}{\In{r}{red}, \In{c}{compu}, \In{i}{interfaz}}{bool}
	{
		\State var $tupVecinos$:tupla $\gets$ Obtener($r.directasEInterfaces$, $c.ip$) \ComplejidadDer{1}
		\State var $itcompusDirectas$:itConj(compu) $\gets$ CrearIt($tupVecinos.compusDirectas$) \ComplejidadDer{1}
		\State $res$:bool $\gets$ $false$ \ComplejidadDer{1}
		\While{HaySiguiente($itcompusDirectas$) AND $¬res$} \ComplejidadDer{1}
		\If {Obtener($tupVecinos.directas$, Siguiente($itcompusDirectas$)$.ip$) $==$ $i$} \ComplejidadDer{1}
			\State $res$ $\gets$ $true$  \ComplejidadDer{1}
		\EndIf
		\State Avanzar($it$) \ComplejidadDer{1}
		\EndWhile
	}
	{}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iCaminosMinimos}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{itConj($\alpha$)}
	{
		\State $res$ $\gets$ CrearIt(Obtener(Obtener($r.deOrigenADestino$, $c_1.ip$), $c_2.ip$))	\ComplejidadDer{1}
	}
	{}
	{}
	\end{Algoritmo}

	\begin{Algoritmo}{iHayCamino}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{bool}
	{
		\State var $conjCaminosMinimos$ $\gets$ CaminosMinimos($r$, $c_1$, $c_2$) \ComplejidadDer{1}
		\State $res$ $\gets$ EsVacio?($conjCaminosMinimos$) \ComplejidadDer{1}
	}
	{}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iCalcularCaminosMinimos}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}}{conj(lista)}
	{
		\State $res$ $\gets$ Vacio() \ComplejidadDer{1}
		\State var $conjCaminosImportantes$:conj(lista) $=$ Vacio() \ComplejidadDer{1}
		\State var $pacial$:lista $\gets$ Vacia() \ComplejidadDer{1}
		\State AgregarAtras($parcial$, $c_1$) \ComplejidadDer{1}
		\State $conjCaminosImportantes$ $\gets$ \NombreFuncion{CaminosImportantes}($r$, $c_1$, $c_2$, $parcial$) \ComplejidadDer{1}
		
		%Ahora que tengo los caminos calculo los mínimos
		\State var $itCaminosImportantes$:itConj $\gets$ CrearIt($conjCaminosImportantes$) \ComplejidadDer{1}
		\While {HaySiguiente?($itCaminosImportantes$)} \ComplejidadDer{1}
			\If {EsVacio?($res$) $\vee$ Longitud(DameUno($res$)) $=$ Longitud(Siguiente($itCaminosImportantes$))} \ComplejidadDer{1}
				\State Agregar($res$, Siguiente($itCaminosImportantes$)) \ComplejidadDer{1}
			\Else
				\If {Longitud(DameUno($res$)) $<$ Longitud(Siguiente($itCaminosImportantes$))} \ComplejidadDer{1}
					\State $res$ $\gets$ Vacio() \ComplejidadDer{1}
					\State Agregar($res$, Siguiente($itCaminosImportantes$)) \ComplejidadDer{1}
				\EndIf
			\EndIf
		\EndWhile	
	}
	{}
	{}
	\end{Algoritmo}
	
	\begin{Algoritmo}{iCaminosImportantes}{\In{r}{red}, \In{c_1}{compu}, \In{c_2}{compu}, \In{pacial}{lista(compu)}}{conj(lista)}
	{
		\State $res$ $\gets$ Vacio() \ComplejidadDer{1}
		
		\If {Pertenece?(Vecinos($r$, $c_1$), $c_2$)} \ComplejidadDer{1}
			\State AgregarAtras($pacial$, $c_2$) \ComplejidadDer{1}		
			\State Agregar($res$, $parcial$) \ComplejidadDer{1}
		\Else
			\State var $itVecinos$:itConj $\gets$ CrearIt(Vecinos($r$, $c_1$)) \ComplejidadDer{1}
			\While{HaySiguiente?($itVecinos$)} \ComplejidadDer{1}
				\If {$¬$Pertenece?($parcial$, Siguiente($itVecinos$))} \ComplejidadDer{1}
					\State var $auxParcial$:lista $\gets$ parcial \ComplejidadDer{1}
					\State AgregarAtras($auxParcial$, Siguiente($itVecinos$)) \ComplejidadDer{1}
					\State Unir($res$, CaminosImportantes($r$, Siguiente($itVecinos$), $c_2$, $auxParcial$)) \ComplejidadDer{1}
				\EndIf	
				\State Avanzar($itVecinos$) \ComplejidadDer{1}
			\EndWhile			
		\EndIf
	}
	{}
	{}
	\end{Algoritmo}
		
	%\begin{Algoritmo}{iNroConexion}{\In{e1}{estación}, \In{e2}{estación}, \In{m}{mapa}}{nat}
	%{
	%	\State $res$ $\gets$ Obtener(Obtener($m.uniones$, $e1$), $e2$) \ComplejidadDer{|e_1| + |e_2|}
	%}
	%{$\Complejidad{|e_1| + |e_2|}$}{}
	%\end{Algoritmo}
	%
	%\begin{Algoritmo}{iEvaluarSendas}{\In{c}{conj(tag)}, \In{m}{mapa}}{arreglo\_dimesionable de bool}
	%{
	%	\State $res$ $\gets$ arreglo[$m.\#sendas$] de bool \ComplejidadDer{1}
	%	\State var $i$: nat $\gets$ 0 \ComplejidadDer{1}
	%	\While{$i < m.\#sendas$} \ComplejidadDer{1}
	%		\State $res[i]$ $\gets$ Verifica?($c$, $m.sendas[i]$) \ComplejidadDer{R}
	%		\State $i++$ \ComplejidadDer{1}
	%	\EndWhile
	%}
	%{$\Complejidad{S * R}$}
	%{$\Complejidad{1} + \Complejidad{1} + \sum_{i = 1}^{S} (\Complejidad{R} + \Complejidad{1}) = \newline
	%	2 * \Complejidad{1} + S * (\Complejidad{R} + \Complejidad{1}) = \newline
	%	2 * \Complejidad{1} + S * \Complejidad{1} + S * \Complejidad{R} = \newline
	%	\Complejidad{S} + S * \Complejidad{R} = \newline
	%	\Complejidad{S + S * R} = \Complejidad{S * R}
	%$\newline
	%$S$ es |m.sendas| y $R$ es la longitud de la restriccion mas grande}
	%\end{Algoritmo}
	
	%\begin{Algoritmo}{iRestricciones}{\In{m}{mapa}}{arreglo\_dimesionable de restriccion}
	%{
	%	\State $res$ $\gets$ arreglo\_dimensionable[$m.\#sendas$] \ComplejidadDer{1}
	%	\State var $i$: nat $\gets$ 0 \ComplejidadDer{1}
	%	\While{$i < m.\#sendas$} \ComplejidadDer{1}
	%		\State $res[i]$ $\gets$ $m.sendas[i]$ \ComplejidadDer{1}
	%		\State $i++$ \ComplejidadDer{1}
	%	\EndWhile
	%}
	%{$\Complejidad{S}$}
	%{$\Complejidad{1} + \Complejidad{1} + \sum_{i = 1}^{S} (\Complejidad{1} + \Complejidad{1}) = \newline
	%	2 * \Complejidad{1} + S * 2 *\Complejidad{1} = \newline
	%	2 * \Complejidad{1} + 2 * \Complejidad{S} = \newline
	%	2 * \Complejidad{S} = \Complejidad{S}
	% $}
	%\end{Algoritmo}
	%
\end{Algoritmos}